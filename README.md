# Project Summary - VR FPS Zombies game DEMO

* Unity Hub to manager Unity versions.
* Overview of Unity Interface: Check Help -> Unity Manual -> Working in Unity

## Setup Virtual Realiy Tool Kit (VRTK)

* VRTK in asset store
* Install VR SDKs like Oculus, OpenVR, SteamVR, etc

## Transcripts for relevant sections chapters

### Testbed

	In this video, we're going to be creating a testbed level which is a common thingused in the game industry to createlevels to test out our all of our gameplay elements before we create thelevels that we're going to be interacting it. In order to create atestbed, there are certain key items thatneed to be inside of our level for VRTKto work correctly. We need to have an SDKmanager, the camera rig, and some scriptaliases. The SDK manager or the VRTK SDKmanager component is a required thingthat needs to be in a scene in order forVRTK to work. We only place one of themand we typically create an object tohold them called VRTK SDK manager, justfor ease of being able to find it. Nowthis item is interesting because itmanages all of the different SDKs, all the different software development kitsthat we want to support within our project. So that means we're going tohave a child object for each of thosedifferent SDKs, which are the camera rigswhich we'll be talking about next. Now if you want to know more about the SDKmanager, you can go to VRTK'sdocumentation which I've included at the following link.The second item that we're going to needis the camera rig and the camera rigcontains all of the scripts and headsetinformation that are needed for thespecific devices you wish to support. Soin the case here we have a VR simulator,Unity XR, SteamVR, Oculus, and Windows MR.And so what's going to happen is whenthe game starts, the SDK Manager is goingto look and see what hardware are youusing. And then depending on that, it'sgoing to decide which of these items toturn on and the SDK manager iswhat takes care of that. And so each of these different SDKs can be verydifferent from each other, and this whole set up makes it very easyat the start of the game to switch towhatever one your players want to use.Like we've mentioned before, each of these different SDKs can be verydifferent from each other but you want to have certain gameplayelements no matter what SDK is beingused. VRTK solves this issue throughthe concept of script aliases and whatthis basically does, basically says whatscripts attach to these objects do you want them to be attached to yourcontrollers. So in your case, you may want to have a pointer, you may want to have ateleporter, you may want to have you know certain functionality that you'vecreated that you want to have no matterwhat SDK that you're using. And so whatthe SDK manager does is it looks at yourscript aliases and it says okay, so theleft controller you want to have this component this component this component.It copies and pastes that onto theobjects at the start of the game and this makes it very easy for you tosupport many different SDKs without having to repeat yourself over and overagain. Now that we know that our VR setupworks correctly, it's time for us tocreate a VR testbed level. This is a wayfor us to that our game actually works correctly before we dive into buildinglevels and creating the main content of the game, and this is often what Triple Agames studios will do at the beginning of development in pre-production.They'll test out various mechanics, make sure that they work correctly so thatway they don't have to redo work overand over again as time goes on. So to getstarted with this, we're gonna first create a new scene by going to file newscene. No need to save and we're broughtto this blank new level. Now by default, Unityonly gives us two objects to work with, a main camera and a directional light. We'renot gonna need this camera because we'remaking a VR project and our camera ismoved by our headset which our SDK willspecify. So I'm going to use the Deletekey to remove this object. We want tohave a place for players to walk on so we're not just in the voidso I'm gonna create a blank floor to work with. So I'm gonna go to game object3D object cube and this creates a onemeter by one meter by one meter cube. But we don't want to just be stuck in asmall of an area so I'm gonna make thescale of this, let's say 25 keep theY 1 and make the Z 25 as well. And sowe've got a much larger area to workwith, about 25 meters. Now by default, thisisn't gonna do anything for us and if we play the game, not much is gonna happen.But just that we know that it's there, I'm gonna go ahead and save this sceneby going to file save and it's gonnabring up a window asking where do you want to save this. I think it's a goodidea to organize our project as much as possible so I'm gonna create a newfolder for our game specific stuff, whichI'm going to call FPS game. And then inside of here I'm gonna create anotherfolder which I'm going to call scenes.And again remember that scenes isUnity's word for level. And so from herewe're gonna go ahead and give a name to our level and in our case we're gonna goahead and name it test bed. And then afterwards we're gonna go ahead and hitthe Save button. And we're going torename this object to VRTK scriptaliases, right click then we're going tocreate another empty object. And we're going to go ahead and name this leftcontroller script alias and then we're gonna create one otherobject which are a right-click createempty and we're gonna name it rightcontroller script alias. Right now, wedon't have anything that's associated with it so we can go go back to the SDKmanager. Go ahead and copy the VRTK SDKmanager by going to edit copy and thenwe're gonna go ahead and go back to ourtest bed level and paste this particularobject. Now you'll notice that some ofthe properties are going to be missing.For instance, these script aliasescurrently don't exist. However all the properties having to do with thedifferent SDKs are going to work correctly because we've brought themover here. Now once we have this object,we can drag and drop it to the top of the hierarchy to make sure that it'salways at the top and easy to see. And ifwe hit the play button right now, you'llsee that we do indeed have the abilityto turn around and look. But of course wedon't have much in terms of things to do yetand our controller doesn't do anythingas well. So we're going to need to set upsome script aliases for this to workwith. So to create the script aliases, what we're gonna do is we're going tocreate an empty game object by going to the hierarchy tab, right clicking andselecting create empty. And we're gonnazero out the position of this object,we're gonna move it to the top here andwe're gonna go ahead and name this VRTK script aliases. Right click andwe're gonna create another empty object,which I'm going to go ahead and nameleft controller script alias.And then we're gonna create one otherobject, right click create empty andwe're gonna name it right controllerscript alias. Right now, we don't haveanything that's associated with it sowe'll go back to the SDK manager andthen assign the left controller here, theright controller here. If we attach anyscripts to the script aliases, they willbe attached to the correct controllerdepending on what SDK that we're usingbecause of the VRTK SDK manager. In thenext video, we're going to use this test

### Pointers

	In this video, we are going to learn howto create our first VR element throughthe case of pointers that go from yourcontrollers into the world. This is quiteoften used for things like raycasts as well as for being able to show playerswhere they're going to teleport when you implement a teleporting system. There area couple key components that are used inorder to create pointers. The first ofwhich is the controller events component,the pointer component and then some wayto render the pointer. There are twotypes of those, a straight pointer and a Bezier pointer. The first component thatwe want to talk about is controller events and what this component basicallydoes is it says that within this object,you want to support input events to itlike when you press a button or you movean analog stick. And in order for yourpointers to function, you need to have away for events to be listened to so thisis going to be required on both of our script aliases. And if you're interestedin learning more about this component, you can check out the link here.The second component you're going to need is the pointer component and thishandles a number of different things, including the ability to teleport in theworld as well as some way to display onthe screen. The object, in order to determine how this should be drawnyou'll notice that there is the pointerrenderer option under the pointer activation settings. This needs to have arenderer attached in order for you to be able to see it but this is also used forthings like UI, which we'll explore later on in this course.For more info, check out the documentation. There are two built-inways to render an object inside of VRTK. We have the straight pointerrenderer which is the VRTK straightpointer renderer component. This createsa straight beam with an optional cursor at the end. This is really useful forwhenever you need precision so for instance maybe when you need to click abutton on the screen or you want to have like a laser pointer coming out fromyour gun, and if you want more info on it check out the documentation.The other built-in renderer is theBezier pointer renderer and thiscreates a curved beam created frommultiple objects with an optional cursor at the end. Now unlike the straightrenderer, which just goes straight from wherever you're pointing this one alwaysgoes downwards. It's always trying to go to the floor and it's going to stopwherever that is, which makes it quite often used for teleportation. Before wego about implementing the pointersourselves, let's take a look and see whatthey look like in action. If we go to ourproject window here, we go into VRTKexamples. You'll see that example 2 is astraight pointer and example 3 is aBezier pointer. And you might be wondering what is the difference ofthese, what do they look like. Well we can open up this example level and we cantake a look at. All right, so we're insidethe level and it says here to touch the touchpad in order to activate the straightpointer. So we touch the pad and you'll notice that we now have these lines pointingat various points within the level. Nowa Bezier pointer works a differentdifferently. Again, we're touching a touchpad in order to draw the line but you'll notice the line looks different. It'sactually pointing downwards compared tothe original one.It's also interesting because you canactually change how its drawn in a number of different ways. So for instance,if we press the button to use line renderer you'll see that we're using aline rather than those dots.Likewise, we can also use the customstyle and when activating that it looks a little bit like this. And if you'reinterested in using either of these, it's as simple as changing the propertieswithin the Bezier drawer component. Sonow let's go ahead and see how we can bring this into our own testbed. So I'mgoing to go to the FPS game folder, open up scenes and then open up testbed. Fromhere, we're going to open up the script aliases and we can selectmultiple objects at once by holding down the shift button and selecting multipleobjects. And what this does is if weattach a component, it will attach thiscomponent to both objects. Now, as wementioned before in order for pointersto do respond to controller events, weneed to have a component on this objectto say that we want it to do that. So I'm going to add a component and we're goingto select controller events VRTKunderscore controller events. And we'llleave everything is default for rightnow but we're also going to add a VRTKa straight pointer, renderer and a VRTK pointer.The VRTK pointer has a property herecalled pointer render and it's asking what thing, what should I use to renderthis object. And actually each of thesewill have one for this particular objectso I'm going to drag and drop. I can dragand drop the component, let me move thisdown here. And I can drag and drop thecomponent inside here to the pointerrenderer, click and drag or on the rightobject I'll just do it this way. I candrag and drop this actual object andthen it will show up for me. And so now,if I go ahead and we play the game. If I pressthe touchpad, you'll see that the pointerrenderers are working correctly. You'llnotice that by default it has it so thatit shows up as green if we're on groundbut if it doesn't find anything to collide with, it's gonna show up as beingred. This is due to the fact that VRTKhas built in the ability to teleport. Youalso might want to use a Bezier pointerinstead of the original straight pointerand we can do that quite easily. If we can right click on the straight pointerand remove it from one or both of these,and instead we can add a Bezier renderer.And in my case here, I would need to do the same thing that we did before. Weneed to assign this component to thisobject and we can do the same thing withthis one. So again can assign this way. Ifwe go in and we play the game now, you'll see that if we touch the touchpad andnow is using this different way. In thenext video, we're going to take our knowledge from creating a pointer andcreate a way for us to actually teleport

### Implementing a Teleport System

	In this video, we're going to learn howVRTK has teleportation implemented.There are two different base types ofteleportation within VRTK, a blinkingteleportation and a dash teleportation.The first form of teleportation is a blink teleport. Now this is the mostcommon form of teleportation. It involvesselecting a location, fading the camera to black, changing your position and thenfading back. This is really nice because you don't have any problems with motionsickness. The second form is a dash teleportand this involves you moving from one location to the other in a very quickmanner. And the reason that this is done quickly is though it prevents motionsickness from players not feeling like they're not walking but they're moving.Before we add teleportation to ourproject, let's see how it's already beenimplemented within the VRTK examples. Ifyou'll go to the app project window andthen go to VRTK and then examples,you'll be brought to a number of different examples but the one thatwe're going to be looking at is this one,zero zero four - locomotion teleporting.So we're going to double click and open this and that's gonna bring us to thefollowing level. I'm gonna hit play to show us a little bit about what thislooks like. But before playing, I'm gonna go to the game tab and ensure thatmaximize on play is on. All right, so within this level you'll see that itsays to press the touchpad to activate the pointer. So in our case, if I am theOculus Rift if I push down on the analogstick you'll see the following menu pop up.It'll then say that if I release on thisbutton, it will teleport me. Now in thiscase, this is the blink teleportationwhere I'm actually fading to black andthen moving to that new location. But ifI hold down the B button, it changed ourtransformation mode to insteadgo to the dash concept. So we're going to goback to our test bed leveland then from here we're gonna go aheadand open up our script aliases gameobject. And I want to point out that oneach of these different script aliases,you'll see that the pointer component has a property here called enableteleport. And this being checked enablesyou to have the ability to teleport soif you want to disable teleportation or if you want to only have it work on onehand, this is the way to do that. Now inour case here, we want to have it so thatwe can teleport and by default this doesn't actually do anything because itdoesn't know what form of teleportationwe want to use. So to add teleportation,we need to add a component to a gameobject inside of the scene. So I'm goingto go ahead and from our script aliases here, I'm going to create a child thatfor the time being because all it's doing is teleporting, I'm going to callteleporting. So right click from scriptaliases and then select the create emptyoption. From there and the inspector tab, go ahead and give it a name ofteleporting and then we're gonna go ahead and click on the add componentbutton and we're going to type in VRTKteleport. Now once you've done that, you'll see three options. The basicteleport which just will position youwithin a flat plane of where you're at,the dash teleport which works like that secondary mode which actuallyinterpolates to that location, and wehave the height adjust teleport which isa blinking teleport which allows you tobe placed higher or further down. So if you want to have verticality in yourgame, I would suggest using either the dashteleport or the height adjust teleportbecause those are actually inheritedfrom the basic teleport script. So I'm going to go ahead and select heightadjust teleport and we're going to leave the basic properties all set up but let'ssee what this looks like inside of thegame. Likewise, I can do the same exactthing using the straight pointer as well and it will just go to wherever ourdot is located. And this will allowus to easily get around anywhere within our level that we want to get to, atleast for testing purposes. Next sectionwe're going to learn just how easy it is

### Creating the Gun Prefab

	Sction four, creating weapons. Over thecourse of this section, we are going to dive into all the aspects in order tocreate a simple weapon that can be expanded upon and built on for your ownprojects. While we're only going to bediscussing how to create one gun, the concepts taught within this section caneasily be expanded to create as manyweapons as you'd like for your game. Inthis first video, we are going to seewhat VRTK already has in terms of aninteractive object and see how we can create our own prefabricated object,which we can use within our testbed level. If we go to the project windowhere and we go to the VRTK examplesfolder, you'll notice that item 5 isinteractions interactable objects. And ifyou go through the level,you'll see that as we go through here there's a ton of different objects thatwe can interact with. And so if we goahead and play the game, we'll be able to see some examples of potential objectsthat we can use for our own projects. Allright, so here we are in this new exampleand you'll see that there's an example talking about how the objects aretouchable, touchable, grabbable or usableat the controllers. In this case, you'll use the grab buttons or the triggers inorder to use them. We're gonna go aheadand look at one object in particular andI highly suggest that before youcontinue, that you look at all these objects to see how they interact with and now they could possibly be used withyour game. But for what we are doing, whatwe're going to be doing with our weapon is very similar to some things which youcan do with these particular objects. So to begin with the first thing that we'regoing to deal with is right over here. So we're going to go ahead and move theanalog stick tap in order to move. And you'll notice on the left hand side here,you'll see that there are two fairlysimple guns and if I use this and I usemy grabber, I'm able to pick it up and same thing with the other one. And you'llnotice that if I press the trigger buttonit shoots out a projectile. There are alot of things that are going on behind the scenes here but I think you can seehow these can potentially be used for our own projects. So we're going to beusing one of these as a default that wecan then expand upon and create our own weapon our own way.In our case here, we see that from ourscene from the hierarchy window, you'll see that there are a number of differentobjects here. And scene objects if weopen it up, actually has for each ofthese different stations the objects that we're looking for. Now in our case,our gun is right over here and I couldget it by selecting it. As you can see here it's inside the snap handle station.But let's say I knew the name of theobject but I didn't want to move aroundthe world to get to it, well I can go tothe hierarchy tab here and you'll see that there's this search bar on the topleft of the screen. If you type in thename of an item, so for instance gunyou'll see that it only has the objectswith the word gun inside of it. And in our case here you'll see there's dummygun one dummy gun two. I'm gonna go aheadand just use one of them, it doesn't matter which one and then once selectedgo ahead and press ctrl C to copy thisobject. You can also go to edit copy inorder to save it. We're then going to goto the project view and go to the FPSgame scenes folder and then double-clickto open up our test bed and then double-click to open up ourtest bed. We're going to X out the gunname here and I'm gonna go ahead andpaste this object into the scene. You'llsee it's currently here and if we goahead and play the game, we should seethe gun work out for us. All right, so ifwe turn over here to our left you'll seeit there is the gun and uh oh, it doesn'tseem like I'm able to pick it up currently. In order for the gun to work,our actual script aliases need to havesupport for the ability to grab and useour gun object. But in order to grab anobject, we first have to be able to touchit. So in our case, we're going to goahead and select both the left and rightcontroller aliases. Afterwards we're going to go ahead andclick on the add component buttonand we're gonna go ahead and type in VRTKinteract. Going to use interact touch,that will allow our objects actuallyrespond to being touched and to have the ability to grab it,VRTK interact grab. And then finally,VRTK interact use, so the use is what'sallowing us to use the trigger button toshoot and the interact grab allows us to use the grip button in order to actuallygrab the object. So now if we go aheadand play the game, I can go ahead grabthe object and I can shoot it just likewe did in the previous level. Let's takea closer look at this dummy gun so wesee what we actually have here. You'll notice that the object has a transformlike every other object does and as thisVRTK interactable objects script. Thisis the component that allows us theability to grab and to use theseparticular objects. There's also a childof controller grab attached, which is saying that once you pick it up to snapthe position to this game object, genericsnap handle. And if you click that you'llsee that on this object,that the handle has been positioned at the edge here. So this is where ourcontroller is going to snap to whenever we hold it. You'll also see that there isa grab action component, this enables usin code to be able to do somethingwhenever we grab the rear a normal rigidbody component. Just like Unity isused to which means that the object will fall. And then we have this interactobject appearance script which is usedin order to modify how the object will work when it's being grabbed used, touchedetc etc. We also have interact hapticswhich is used to provide a rumble effectusing a sound for how high or how muchrumble should happen, depending on if it's being used, grabbed, touched etcetc. There's also a script here called gun shoot and later on we're going tocustomize this to be our very own script instead. But since we're going to bemodifying this from the original VRTKelements, I'm gonna rename this objectfrom dummy gun 1 to instead the handgun,because that's what we're actually going to be building. Press ENTER to completeand afterwards I'm gonna go ahead and goto FPS game here in the project view and we're going to right click and create anew folder called prefabs. And then fromthere, we're gonna enter the prefabs folder and then I'm going to drag anddrop the handgun inside here and thenlet go. It's going to ask if we want tocreate a new prefab or a variant. We're going to go ahead and create an originalprefab so that will allow us to be ableto remove things and not have to worryabout modifying what VRTK originallygave us. And it also helps protect theoriginal VRTK object so if anythingever went wrong, we can always refer to that later on. So I'm going to go aheadand hit original prefab and you should see it is now locatedhere. And if I double-click on this or Iclick on the open prefab button from theinspector, you'll see this object in awindow that is isolated from everything else in our scene. And this will make itvery easy for us to make adjustments without having to worry that it's partof our particular level. And so with that, we're gonna start working on the nextaspect of our gun. In the next video,we're going to see how we can use somebuilt-in functionality from VRTK tomake it so that our gun is always being

### Automatically pick up an object

	In this video, we're going to see how to automatically pick up an object and keepit no matter what's going on inside thetitle. So in our previous video, in order to pick up the gun we have to actuallyphysically hold it. But most people whenworking with a VR game, they're already holding on to something like forinstance with the Oculus you're already holding on to the Oculus controller. Soyou might want to make it so that when the player starts the game they alreadyhave the gun in their hand. And so in order to do that, there is a componentcalled the VRTK object auto grab whichcan make it so that you automatically have an object when the scene starts. Soin order to do this, I'm going to goahead and back out of the prefab windowby clicking on this little left arrowhere. This takes us back to our scene.Let's go to the VRTK script aliases here.Open it up then select both the left andright controller aliases. From there, go ahead and scroll all theway down and then hit the add componentbutton. From there, we're going to selectVRTK object auto grab and it's going togive you an option here of what objectto grab. It's asking for an object withthe VRTK interactable object componentassociated with it. I'm going to go aheadand drag this prefab object into thisand I'm going to check the object isprefab option. And what this will do isit will spawn the object when the scene happens. Automatically grabbing theobject works well but when the game starts,it's going to drop the object because we're currently not holding it. So if wewant to prevent that from happening, wecan go to the handgun object and from here you'll see all the scripts that areassociated with it. And from here, you'llsee that there is this valid drop set todrop anywhere. Click on that and thenselect no drop. This will make it so thatthe player cannot drop this. Now let's go ahead and play the game and see whathappens. As you can see, now when the gamestarts I'm already holding the gun and Idon't have to hold the holding button in order for the gun to work. Shooting alsoworks fine on both objects. Now that wehave our objects holding guns at the beginning of the game rather than havingto pick it up, we can actually go to ourtestbed level, select the handgun object,not the prefab and delete it from the scene.And with that, we now have a gun that will automatically be held at thebeginning of the game. Now that we have our weapon functionally working, we're

### Customizing the weapon appearance

	In this video we're going to customize our weapons appearance.While this weapon functionally work similar to what we're lookingfor.You often times in your games,you want to customize how your weapons look so we'regoing to take a look and see.Just how we can customize this weapon to fit whatevergame it is that we're trying to get through.Now modeling the weapon ourselves isn't within the scope ofthis course and I do highly suggest that you checkout 3DS Max or?Maya tutorials in order to learn how to do that,if that's something that you want to do.What we're going to focus on is the actual puttingthat model in getting it to work with inside ofour game.So if you go and what to do that.We're going to use a free asset from the assetstore.So just like we did with the VRTK.We're going to start off by going to the assetstore tab.Afterwards, once we load this up.We're going to search for what we're looking for inmy case,we're going to say gun.And you'll see that there are a lot of optionsthat we could potentially go for going to right clickmaximize here there's 1700 different guns available.Now again we don't necessarily have to pick something that'ssuper expensive we could actually go to sort by.In select price low to high and in our casehere.This handgun looks kind of cool so maybe will usethat and then from here,we can go ahead and click the download button.Once downloaded will click import.And you'll see that it's got.A number of different files that we might want touse.Go ahead and say import.So now we can get out of the asset store.And we can go into the nokobot folder to seethe actual gun.It looks like it has a display scene to showus what it looks like.So we can go ahead and open that and hitplay and you'll notice that when we click.It displays an animation in it,shows a muzzle flash.Looking inside the actual scene,you'll notice that there are 2 main objects here andif you select the gun object.You'll see that it currently contains anAnimator as well as a simple shooting script.Now obviously we won't be able to use the simpleshooting script in our VR title,but it has a number of useful things that wemay want to have.In our own project. The animator component contains animation dataand if we double click on this.You'll see that this state machine, the animator state machinehas 2 states inside of it idle and shooting.Which is set up conditionally?Based off of a trigger which is called fire,which is located in the parameters.So we can make use of these animations,we can make use of these details.So I'm going to go ahead and select this object.And this is also already been created as a prefab.So we can make use of either one of theseinside of our own scene.So I'm going to go back to FPS games scenes.And we're going to open up our testbed.And no need to save.I'm going to go to FPS game prefabs and thendouble click on handgun.In our case here were brought to this basic handgunand I'm going to change our Camera view to be.Top down so I click on the Y here,you'll see that were brought to the Top.And I'm going to go ahead and go to theprefabs for are the gun that we're going to beusing?Or the model file completely up to you and we'regoing to grab the weapon that we want to use.In drag and Drop it into the scene.Now again, you may notice that by default,it moves very far away from where this gun actuallyis.So I'm gonna go ahead.Let's move this so it's separate an I'm going tochange the position to 0.0, 0. So it's centered from where the gun objectnormally be so by zooming in it.Looks like this gun is actually much larger.Then the gun inside the scene so change the scaleof this to .0,one .01. And then the same thing in the ZAxis point 0one and you now we have a better idea of.Of what the size of this object is let's changeit to like .point 1,Point 1, point 1. And what we can do iswe can use the rotation in the scale tools tomake this a little.Easier on us. So if I change the rotation thatis Y Axis to 0 looks a little better.And what we can do is we want to alignthis to fit within this gun object.So we're going to go to the scale and I'mgoing to grab the center to evenly scale this object.And.I'm gonna move over to this axis.To make it sure that our object is centered lookslike it is.Enema shifted over a little bit like that.And then we're going to do the same thing forthis as well.Looks like it's a little back.So move it forward here.And now it looks like it's fitting this area prettywell.So now if we select the Barrel object.You'll notice that there is the mesh renderer component.Which is in charge of drawing the barrel on thescreen?Since we no longer need that I'm going to rightclick here and select remove component.And you'll see that we can see the gun veryclearly now.Likewise, I'm going to go ahead and do the samething for the handle.By going ahead an right clicking on the mesh rendererright clicking an removing the component.And so now we still have the box Collider.So it's still gonna fall down correctly if it needsto it's still going to interact correctly.It just visually now looks like a traditional handgun andagain note that this handgun is just the Transform.It's not the script version,which is located inside of the prefabs active game folder.we are going to add that functionality.Later on by ourselves. So afterwards,I can go ahead and go back to our leveland let's run it and see what the.What are result looks like?Alright so now. We've gone ahead and we've got ourgun model in the scene.And it's shooting as well, you'll see uh there seemsto be some kind of issue at the offset.But we can go ahead and fix that.If you go to our prefabs and go to handgun.You'll see that there is the Bullet Spawn position,which is where the bullets are going to spawn withinthe scene.We will go ahead and shift this up.So that matches right here.And now when we jump into the game it looksa whole lot closer to what we were looking for.In the next video. We're going to see how wecan make use of the C sharp scripting language.To customize our gun behavior using functionality from a parentclass to then do our own thing.

### Extending Gun Behavior with C# and Inheritance

	In this video, we are going to use the C# scripting language in theconcept of inheritance in order to create our own gun behavior, usingfunctionality from a parent class tothen do our own thing. This will include doing things likeplaying animation events as well as how to display muzzle flashes when we fireour gun. As we've discussed previously,our handgun actually contains a component called gun shoot which is whathandles shooting projectiles anddisplaying things on the scene. Well we haven't actually looked at that scriptyet and so that's what we're going to do first in this video. By double clickingon gun shoot here,this is going to open up Visual Studio2019. In this script, you'll see that there are a couple interestingproperties which we already saw before.We have our linked object which is the interactableobject, the projectile that we want to shoot, the spawn point where should it bespawned from, how fast it should be and how long should the projectile live.We've got on enable which sets up someproperties and it says that wheneverinteractableobject used on our object to call this function calledinteractable object used. And withdisable, it's removing that script from happening. Now inside of this script, it'ssaying when we use this object we're calling a function called fireprojectile. And this is what actuallytakes care of the spawning of aprojectile to shoot towards us and itwill add a force to move it forward, andit says to destroy it after a certainperiod of time. Now we want to keep mostof this functionality but we want to addon to it so it makes sense for us tomake use of the C# property ofinheritance to instead of extending from monobehaviour,creating a script that will extend fromgun shoot. So let's go ahead and see howthat we can possibly do that. So to startoff with, I'm gonna go ahead and go to myFPS game folder and then from here we're gonna create a new folder which we'regoing to call scripts. So I'm going to right click and then select createfolder then type in the word scripts.From there, we'll enter the folder andthen I'm going to right-click and createa C# script. Once created, we'regoing to type in the name of the script which I'm going to call handgun.Afterwards we'll double click on it to enter Visual Studio.Now from here, we have the basic Unityscript but by default it's attendingfrom monobehaviour. In our case, we wantto extend from gun shoot so I'm gonnareplace here with gun shootbut it's not going to know what thisclass is. And the reason why is that theguns shoot script is actually part ofthe VRTK.examples namespace. So I cango ahead inside here and say using VRTK.examples. Now again, we don't needa start and update function right now so I'm going to go ahead and select thatand remove it. And then inside of here,I'm going to instead override aparticular function, the fire projectile function. Notice that this function ismarked as virtual. This means that it's possible for me to override it when Icreate a child version of this component.So I'm going to go ahead and select the line, copy it. I'm going to paste it here.I'm going to change the word virtual tooverride. Now we still want to do theparent version of this function. So I'mgoing to make use of the base keyword which is basically a way for us toaccess the parent class of this object.I'm gonna say fire projectile thenafterwards we have to decide what do wewant to do to change this. Well, one thingthat we might possibly want to do is have it so that we play that shootinganimation whenever we actually fire the projectile, but that's gonna require alittle bit of work from us ahead of time. So let's first save this script andlet's add in a debug dot log statementand gunshot. Save this and that we will be able to know for sure that thisfunction is actually being called. So I'm going to go ahead and come back here andthen we're going to select the handgunobject and then we are going to replacethe gun shoot script with handgun. Sowe're going to drag and drop this on top here,and you'll notice that by default thesethree properties aren't being set. So I'mgonna go ahead and select each of these objects individually and we're going todrag and drop them into theirappropriate slots. Afterwards, we're gonna go ahead andremove the gun shoot script and nowlet's go ahead and play the game. We'rein the game, we've got a gun, we can shootshoot shoot. You'll notice on the bottomof the screen here, we see handgun shotand if I click here, you'll notice thaton the bottom of the screen here we see handgun shot. And if we click on there,it'll open up the console window and weare seeing debug.log statement showing up here, showing up for each of the shotsthat occur here. This means that we know that everything's working correctly andwe are extending this built-in behavior.So we're going to go ahead, type in animatorand then it's going to ask for whatcontroller we want to use. Again we couldcreate one from scratch but since the boolet the gun that we downloadedalready contains one, we can go ahead anduse that. So inside here you'll see thatthere's this handgun state machine. I'm going to drag and drop it in heresome way to set this animator and tocall the fire trigger. So we're gonna goahead and go inside of our script here andI'm going to create a new publicanimator, which I'm going to call anim.And we're making it public so we need toset it through the inspector. But now, instead of just calling handgun shot I'mgonna comment that out and then here I'mgoing to say anim dot set triggerfire. And so this will cause the fireevent to happen whenever fire projectileis being called. If we come back into Unity now, you'll notice that we haven'tassigned the anim property. Under ourhandgun object, we now need to set anim so I'm going to go ahead and drag anddrop this object inside here and nowlet's go ahead and play the game. And sonow, whenever we fire the gun it's playing that animation that we sawbefore. It looks like there's a bit of adelay before the animation happens though so I think we're gonna need tofix that. I think I'm gonna change thiscomponent so instead of going from idleto shooting this way, I'm going to changeit from any state go to shooting. Soright-click make transition select shooting and then from here, we're gonnasay there's no exit time, no transitionduration and the condition is that firehas happened. And we're going to leavecan transition to self to happen so thatway each time we'll see the fire happen.There we go so now if we keep shooting,we will continuously see the firing animation happen and it reacts to uscorrectly. Another effect to reallypolish our gun would be to make it so that whenever we shot a gun that wewould see a muzzle flash. And if you goto the Nokobot folder, you would noticethat under the effects folder there isalready a muzzle flash prefab whichcontains a particle system, creates a number of these textures on the screenat once, which will work quite well forus. Aand so what we can do is we can goinside of our handgun script and we'regoing to create a new public variable,which we're going to call flashprefab.And so inside here, we can use the same function that we used to spawn a booletwhich is instantiate. Now there are a number of differentversions of instantiate that you can use but the one that I often like to use isone that takes in three parameters. The first being the object you want to clone,the second being the position you want it to be cloned at, and the third is whatrotation should it have. The first one'seasy enough, it's the flash prefab. But for the secondand third parameter, we need to know where we want that flash to happen. Well,it's gonna be the same location as wherewe're spawning our boolet and so we can figure that out by just looking at thefire projectile function. So I'm going to right click here and say go to definition.And inside here you'll notice that thereis a property called projectile spawnpoint, which is actually the position in the rotation that it's using here. I'mgoing to go ahead and copy paste thatand again to make it easier to see, I'mgonna add a comma here, indent indent sothat we can always see what's going on. But it's using the projectile spawnpoint variable which again is set in theparent class. If you look here, projectilespawn point and we're just spawning theprefab at that same location. Now we might want to destroy this prefab aftera short period of time so we can justsave var indent to leave that.Now I can say destroymuzzle flash and then how long do I want to wait before it gets destroyed. I'mgoing to say 0.3 seconds because I know the particle system only lasts 4.2seconds. So with that, I'm gonna go ahead and save and let's see what it lookslike inside the game. So now we need to go ahead and go to the handgun andassign the flash prefab to this muzzleflash object, and if all went well let'ssee what happens in the game. So now,we've got the gun and if we shoot there we go.In the next video, we are going to seehow we can use audio clips to play sound effects as well as provide hapticfeedback from when we're interacting in

### Implementing Sound and Haptic Feedback

	In this video, we are going to see how wecan use audio clips to provide hapticfeedback or rumble to our controllerswhile we're playing, as well as how to play sound effects, for instance when weshoot a gun. One of the other key things we can do to improve the quality of ourtitle is by having sound, and this isn'tyet oftentimes people will wait to the last minute to put in their game but itis one of the key senses that we have to feel immersed in an environment. This isespecially important for doing VR games.So in our case, we're going to want somesounds for the guns being shot um andfor picking up etc etc. Now again, wedon't have any built in and the current handgun doesn't have that for us sowe're gonna once again go to the Asset Store to find something to work with.So I'm going to go to the Asset Storetab and we're in a search for gun sound.Once I've done that, I've already gone through and I found this free assetcalled Fog of War Gun Sound FX Free.I'm going to go ahead and import that and we're going to just bring everythinginto our project, import. And you'll see that there's an audiofolder that's just been added. We've gotthis guns. Now if you select this object, you can always hit the play button tosee what it sounds like. Okay.Okay, so in our case I think impactor ispretty good. If we go to the handgunobject, you remember before we saw thiscomponent of input haptics for thingsto place whenever it's grabbed or usedor touched. Let's go for the on use touse the impactor sound effect. I'm alsogoing to go ahead and use the the theyshoot effect for the on grab.Let's go ahead and play the game and seehow this looks.You may have not noticed this in the video but for those of you that areactually holding controllers, you'll notice that there's a rumble effectgoing on which actually uses the soundeffect to actually play of theappropriate sound as a rumble effectinside of your game. Now to actually hearthis sound inside of your game, we needto go ahead and do some code. We're gonna go ahead and go to our handgun scriptand we're going to create a newaudio clip variable,which is going to be shoot sound.And we are going to callaudio source dot play clipat point and we're going to provide theshoot sound. And then, we're what positioned we want the sound to comefrom. Well, we can make it the position ofthe projectile or the gun itself. In ourcase, I think it should be inside the gun itself because that's where the soundnormally would come from. So I usetransform.position. I'm going to savethen let's go back into our handgun here.Here, it's gonna show up a new variable.It's gonna have new shoot sound but a drag and drop impactor here and nowlet's go ahead and play the game. And sonow, you'll know the sound effects arenow playing whenever we shoot and we can use the same function for any othereffect we want to have. Now that we haveour weapon working, we now need to have something for our player to fightagainst so in the next section we are

### Overview of an Enemy AI

	Section 5, developing an enemy AI. Over thecourse of this section, we are going to be creating the foundation of our enemyAI for this particular project. In thefirst video, we're going to be starting this process of creating an enemy of ourvery own. This enemy will be a meleeenemy which will be able to walk towards the player and attack him whenever hegets too close. He should be able to takedamage from our weapons and die as well,and in the meantime we'll learn a lot of different aspects about the Unity enginewhich will be useful for when developingenemies of your very own. To get startedbuilding our enemy, the first thing we'regoing to need to do is have an enemy for our player to fight. So I'm going to goahead and exit out of this here and we're going back into our testbed level.And we're basically going to create onesingle enemy first and then, just like wedid previously create a prefab where we can create as many enemies later on aswe like. Now to start off, we're going tofirst get some assets in order for us toprototype this enemy. And you know what we've been doing so far so we're gonnahit the Asset Store once again. I'm going to go ahead and go the Asset Store taband this time we're going to decide what kind of enemy we want to have. Now in mycase, I'm gonna use a zombie because it'sa classic enemy. I'm gonna go ahead andtype the word zombie and you'll see thatI've already purchased this zombie here and it's also free. So we're gonna goahead and use this zombie character. We're gonna go ahead and hit the import buttonand you'll see that this actually contains a lot of interesting stuff forus. It already contains some attack,falling back, idle, walk, walk in placeanimations. It's got a animatorcontroller already built in but we maybuild our own if we need to. We have ademo Unity file, we have materials, thetextures, the actual model file itselfand there is already a prefab that'sbeen included. Now of course, we're going to want to customize it for our ownproject but I'm going to go ahead and hit the import buttonand that'll bring all those files intoour project. I'm gonna go ahead and right-click on the Asset Store againand unmaximize. Let's go ahead and open upthe zombie folder and open up the demo.All right, so when we hit playyou'll see the zombie's here and it'sanimating. It starts off with an idle, it starts walking towards us, it startsattacking, it falls. So perfect, we have a lot of things that we can make use ofwith this character. The zombie prefabthat's been included already only has a transform and an animator associated withit. The child has all of the individualpieces. If you go to the current animator,you'll see that it currently has insidethe animator toolbar, you can use the middle mouse collect button and drag inorder to see things easier. And you'll see that it just goes from one state tothe other without any kind of condition.We're obviously going to want to create our own when we start actually buildingour character. Let's go ahead and go back to our testbedlevel and we can go ahead and bring the zombie in. We're gonna go to theproject window and then open up the FPS game scenes folder and open up our testbedonce again. From there, I'm gonna go ahead and drag and drop the zombieprefab into our scene and then let's goahead and take a look to see how itrelates to us within our scene. So if welook around, let's get a little closer tothe guy and he's already given me theheebie-jeebies. So by default, let's movehim a little bit closer so we can see him a little bit easier. And we can goahead and rotate him by clicking on the rotate tool and dragging him around. Ifyou hold down the control key, it willsnap to certain but to 15 degreeincrements by default. But you can set that yourself by going to edit and thenselecting snap settings. You'll see thatby default rotation is set to 15 degrees.Now in our case, we don't want to use this built-in controller so I'm gonna goahead and delete this and we're going tocreate our own animator controller instead. So I'm going to go ahead andcreate a new folder inside of the FPSgame folder, which I'm going to call the animations.And then from within there, I'm going to right click and say create and thenselect animator controller. We'll sayzombie fps. Now within here, this is ablank animator. There's no states that have beenattached to here by default. We'll goahead and add in just one single statefor right now. We go to animations and we go to idle here, gonna drag anddrop this in. Now we also need to goahead and go to our animations folderand drag and drop the zombie fps into the controller here. Now we go aheadand play. We're already here, we're already at the zombie and he is lookingaround and he is pretty scary. But here'sthe thing,currently boolets don't actually doanything to this guy. So we want to haveit so whenever we shoot him, he's goingto take damage and eventually that he's gonna die. So that's what we're going tobe doing in the next video. In the nextvideo, we are going to learn how to have our enemy react to being shot by ourboolets and how damaged as well as how

### Damaging the Enemy

	In this video, we will learn how we canhave our players bullets react to anddamage the enemy through Unity'sbuilt-in collision system in events. To do this, we're going to want to create anew scrip. So from within our scriptsfolder under FPS game scripts, we'regoing to right click and create a new C#script and we're going to give ita name of zombie behavior,Capital Z capital B. Now again, you'llnotice that zombie behavior I spelled asdot iour, that's because thedefaults file the default componentinside of Unity is called monobehaviour,spelled in the British way, and in mycase I just want to be consistent. In ourcase, we want this enemy to take damageand we want him to be able to die. So I'mgoing to go ahead and introduce two newvariables to our project.Current health which I've made private and is an integer which means a wholenumber and we'll have another integer,which we'll call starting health or just health.Now this integer health I marked as public so we can set it inside the Unityinspector. At the start of the game, I'mgoing to go ahead and set the current health of our player to whatever we setunder health. This will ensure that nomatter what if we restart the game or anything like that, that the currenthealth will always be reset to whatever we initialized it to. We're not gonna beusing the update function right now so I'm gonna go ahead and get rid of it. Andwe want to do something whenever abullet hits this zombie. So that means that we're going to need to registersome kind of collision event to it. Nowto do so, we need to add what's called acollider to this is on the object. Now again, if you select the zombie bydefault there's just a transform and an animator, there's nothing to actuallyregister that there's been a collision.So in order to add collision, we're goingto need to go ahead and say add component or click under component. Thengo to physics and then you'll see that there's this whole section here ofcolliders and these how this objectshould respond to collision. Now oftentimes, you want to make thecollision as simple as possible for efficiency sake and because we mighthave many zombies on the screen all at once, instead of using something complexlike a mesh collider I'm instead goingto use the capsule collider. Now if yougo to the object here, you'll see thatthere is this yet this green littlecircle here on the bottom of our objectand that is the collision data. So ifsomething were to go inside of there and at least one of those two objects has arigidbody component, it will respond tothat and it will have certain events. But this isn't necessarily the same size asour enemy. So in order to make this work,we're going to need to modify some of these properties.Now the first here you'll see is centerand this is an X Y Z, it's a vector3 ofhow if this should be offset in any way.Well I think we need to offset this in the y axis and of course I could type ina number here, like for instance 2 and it would movetwo units above. But I want you to noticethat if you put your mouse over any of these properties, you'll see these littlearrows show up on the sides of yourmouse. If you click and hold on that anddrag to the left, notice how the valuemoves down and right moves it up. So I'mgonna move this to the center of the character which looks to be around 1.You'll also see the radius and the height property. I'm gonna want theirheight to be higher so it actually fits my character, so maybe something likelet's just say two, maybe shift it downjust a little bit yeah. It looks betterand we can go ahead and change theradius a little bit as well, make it alittle smaller to ensure that it fitsthe body. And let me just change theheight to about 1.9, that looks aboutright. But again, we can keep tweakingthis over and over again. The thing thatmatters most is the fact that we do havea collider there. This is all we need in order for the collision events to workinside of Unity. If we have anotherobject with a collider and a rigidbody component it will respond to thesecollision events. And thankfully, ourbullet prefabs do have both a colliderin our rigidbody so we don't need to necessarily put a rigidbody on thiszombie. And if we are to jump into the game now you should notice that thebullets will hit the zombie and they will reflect.As you can see, the bullets are now stopping when they hit the zombie butthe zombie is never dying so that's whatwe're gonna be implenting next. To do this, we're going to need to go back intothe zombie behavior. So go ahead and double click on it and we're going to bemaking use of another function which isbuilt into Unity which is called oncollision enter.now this function has one input to it oftype collision, which has informationabout the collision that has occurred.Later on we're going to use thatinformation for being able to show aneffect whenever we hit the enemy, but for right now we care more about actuallyjust taking this damage. So let's goahead and check if our health is higher than zero.Then we want to take some form of damage.One of the things that I like to teach my students is to take the things thatthey're trying to implement and break them apart into smaller and smallerpieces. Because we know what we want todo here is for the zombie to take damage,rather than writing the whole behaviorwithin this on collision einter function,we can instead create our own functionmaybe called take damage for example andcall that and write all theimplementation of taking damage insideof there. So, to do so we just need towrite the name of the functionand we need to provide any kind ofparameter that we want in terms of whatdamage we want to do. Maybe we want topass in how much is damage that we aregoing to be doing. Now in my case, let'sgo ahead and just say 35, so in this case it would take three shots in order tokill the the enemy, and we're gonna havea semicolon there. And again, so just likeand so in this point you'll notice these red lines and that's because thefunction doesn't exist yet. But there's two ways that we can actually implementthis. We could write it ourselves by doing the followingand in this case, I use the same functionname. I inputted a parameter which we put35 in there. The return type is voidwhich is nothing and its public so it'saccessible to other classes. Alternatively,I can also select take damage here and you'll see that when I highlight overthis and says that it doesn't exist. It says to show potential fixes you can hitcontrol period. If I do that, you'll see that it says to generate a method calledzombie.behavior take damage. Let's go ahead and hit enter and it alreadyimplemented the function for me. Now in this case, it marked it as privatebecause it's not being used by any other class and that's probably a good way togo about doing it. The name of V isn'tvery useful because it doesn't actuallytell me what this number is, so I'm gonnago ahead and change the name to damageto deal. And here it's saying to throw anexception saying that we haven't implemented the function yet. Well, we cango ahead and do that real quick. So in my case, what I want to do is I want tosubtract from the current healthvariable by 35 by damage to deal. So Ican just write,in this case I'm saying that current health is equal to the current value ofcurrent health minus damage to deal. So if current health was a hundred itwould be 100 minus 35 would besixty five would be my current health. Now programmers like to write this in acondensed format and so instead of saying current health is equal tocurrent health minus damage to deal, I can just writeminus equals. And what we can do now is we can say hey,so if our health is less than zero or equal to zerokill the zombie.When I say here destroy game object, I'msaying to destroy the game object thatthis component is attached to, thiszombie behavior. Now some people who have programmed before might know the thiskeyword. If you tried to destroy this, youwould just be destroying the zombiebehavior component not the actual zombieobject in the scene. So that's why we're using game object here. I'm going to goahead and save this script and then we're gonna go ahead and go tothe zombie, but the zombie selectedattach the zombie behavior component toit. Now again health here is the startinghealth and right now it's set to a hundred. So let's jump in the game andsee what happens. So at this point, afteradding the zombie you'll notice thathe's done. One thing to note if you lookat the bullet prefab that we're currently spawning, which is located inthe VRTK examples example resourcesshared resources prefab guns bulletsfolder, you'll see that there is arigidbody on the parent object butthere's also two colliders. The basecollider with a capsule collider andsphere with a sphere collider. Nowbecause there are two colliders, there are actually two on collision enterevents that are occurring when the collision takes place. One of the waysthat we can work on this issue is byrandomizing, so instead of 35 we can give a random amount of damage that shouldhappen. And one of the ways that we cando that is by saying randomdot range and then we can pass in twonumbers, let's say between five andtwenty. Now random dot range is afunction that exists as part of Unityengine dot random and right now it says it doesn't know which one to be using. Wecan fix that by saying Unity engine dotrandom dot range and this will give us arandom number between five and twenty.And so nowit takes a random number of shots for the enemy to die.In the next video, we're going to learn how we can have our enemy animate

### Animating the Enemy

	In this video, we're going to explore howUnity's built an animation system, how we can use it further by creating our ownanimation system from scratch for our zombie enemy and having it react tobeing shot. Currently, the zombie can be hit, it canbe dead but there's nothing going on in terms of its animation and thischaracter we want to have a little bit more detail. We want it to fall backwhenever he dies, we want him to reactto being attacked and we want him to be able to attack himself. So with that inmind in this video, we are going tocreate the ability for the zombie to beanimated. We need to go to our zombieobject and you'll see underneath the animator component there's thatcontroller variable, which again if we click here you'll see is that animationthat zombie FPS that we created before.Now double clicking on this or clickingon the animator tab with zombie selected,will bring us to the animator for thiszombie object. Now in our case, wecurrently only have the idle state andyou'll see that from entry, there's thisdefault line that's been created. This iswhat we call the default state of thestate machine and idle is the default state, so by default is just gonna keepbeing in the idle state forever and forever and ever.Now we can add additional states oradditional boxes that the character canactually go into. In particular, we mightwant to have a state for whenever thezombie dies. So we can create this stateby either right-clicking and sayingcreate state or we can go to the zombiehimself, go to his animations folder andthen drag and drop the animations thatwe want in. Now in our case, for dying wecan use falling on back orgoing back and we also will eventuallywant to add in additional states. Now,falling back we want to have happenwhenever the zombie dies so we need tohave it there be some kind of transitionfrom one state to another. But we don'treally care what state the object is in.Whenever his health is zero, we want togo to this falling back animation. And you'll notice here we have this wholeany state property. This is saying fromany state we can create a transition andno matter where it is, if this particularstate is true it will go to falling back.So I'm gonna right click here and I'mgonna select make transition. I'm going to select falling back and then click tocomplete this transition. Now by default,you'll see this line. If I click here you'll see inspector tab fills thedetails about this transition and thething that's most important is conditions. Conditions is what has tohappen for this to go here. Now forinstance, if I play the game now there is no condition which means it will alwayshappen, which we don't want. So with thatin mind, we can create a variable calleddead and if that variable is true thenwe will die. So underneath the animatortab, you'll see there's this left sectionand there's a layers section and thenthere's a parameters. We're gonna want to select parameters. You'll see there'sthat little plus sign to add a new parameter to this animation statemachine. By clicking here, it will ask us what kind of variable we want, either a float,an int, a bool, or a trigger. In my case, Iwant bool. It's gonna ask what name do wewant, I'm going to say dead. And by default this is unchecked whichmeans it's false. So under conditions Ican now hit plusand now it's saying, if dead is true gotofalling back. But here's the question. Howdo I set this bool. Of course we can set the default parameter inside of here but toset it ourselves, we need to set itthrough code. So inside our zombiebehavior, we're gonna need to add a new property to our zombie behaviorcomponent. So here we've created a private animator called anim just likewe did with the handgun and inside of start we're going to go ahead andinitialize it.And then, in order to send information tothe state machine we can go inside herewith our take damage function, if currenthealth is less than zero.Now the set bool function takes in twoparameters. The first is either an int ora string, which is what is the name of the parameter that you want to set. Thesecond parameter is what value do you want to set it to. So I'm going to goahead and say deadand I'm going to say true. So anim. set bool dead to true. So whenever ourhealth is less than or equal to zero, wesaid true andwhile at this point, we're able todestroy the game objects we're notactually seeing this animation happen. Sowhat we can do is instead of destroyingthe game object, we will use the destroythis property anim bool dead true thenwe're going to destroy this component.And that will mean that the behaviorwon't happen anymore. All right, we'reback in.So it looks like right now, if we look atthe game it is changing the animation but it's consistently changing back andforth back and forth back and forth. So if we select from any state to fallingback, you'll see there's a property here called can transition to self. If weuncheck this, this will make it so that if we're in the falling back state wecan't go back to it. So now let's goahead and play. So now he goes to thisdeath state and he stays there. So we currently have it so that we can fallback, have nothing for when the zombiegets hit. And we want to have some kind of feedback for so that the player cansee oh, my hit is actually happening. But you'llnotice that none of these statesactually have a hit animation, there'sjust the death animation. Well one of thethings that we can do is we can actuallycreate our own hit animation usingthe first part of falling back and thentransitioning back to this through ourgeneral idle state. So just like before,we're going to use the any stateproperty and I'm going to drag and dropfalling back as a second state here. ButI'm going to rename this state fromfalling back to instead be hit, so thatway it's easy for us to know that thisis actually happening. And this one, we'regoing to create a new parameterand this time we're going to use a trigger. Now a trigger registers in aone-time event that only happens onceand then it's done. It's not like anyother property like a bool is always aparticular way. Triggers happen one anddone and I'm gonna name this trigger tohit. And then under here, we're going to create a transition by right-clicking onany state, selecting make transition andthis time we're going to select hit.Under the parameters or rather under the conditions,we're gonna hit plus and then instead ofdead here we're going to say hit. So if the heck trigger happens, we're gonna goinside here. But under this, we're gonnago ahead and open up settings and wewant to immediately jump this animation.So we're gonna change the transition duration to be zero and we're going touncheck the fixed duration property.Now inside the hit state, we actuallywant to be able to go back to the idlestate without much time at all. So I'mgonna go ahead and right-click on hitand make a transition to dive to theidle state. Now under this property, we'regoing to have an exit time but it's gonna be very short. Now to visualizewhat this looks like, you'll see it there's this bar here. Now if I play this,you'll see that we have that big jump before we get knocked back.But if I change the exit time to insteadof 0.6 to be 0.1,you'll see it only pushes your hand backjust a slight bit. I also might want to make the transitiontake a little bit longer and you'll see that that makes it longer to go from onestate to another. Now we can go ahead andhit play and there we go. We got something thatlooks a little bit like just being hit and then coming back to its normal self.So in order to make the hit effectactually happen in the game, we're goingto once again have to dive into somecode. So inside here, when we have ourtake damage function setting the bool here if we're deadbut otherwise we can use the hit triggerbecause we know that we took damage. So here, if this is false it will dowhatever is inside here and I'm going to sayanim dot set trigger. And this onlytakes in one parameter which is going to be either an int or a string for thename of this trigger you want to trigger.We're gonna say hitand we'll go ahead and save. Go and hitplay and so now and so now you'll noticethat the hit animation as well as the death animation are now perkingperfectly for us. There are two otherstates that we may want to bring intothis project, one for walking and one forattacking. We're gonna go ahead and dragthem in, walk in place which is one thatdoesn't move by default. We're going to actually use code to move our enemyinstead and we're going to have one other property, which is going to be aattack and attackis going to use the any state propertyjust like before. And walk in place isgoing to use another parameter as well. From here, let's go ahead and maximizethe animator toolbar to make it a little easier to see what we're doing here,and again remember middle mouse button to move. We are going to create atransition for any state to attack andfrom idle to walk and then walk back toidle. To do this, we're going to need tocreate two new parameters. The first ofwhich is going to be a float so underhere we're going to select float and we're going to call it speed,and the other is going to be attackingand attacking is going to be a bool.So from here, we'll go ahead and savefrom any state to attack,right click make transition. Go to attackand then we're going to create a transition from idle to walk in placeand then for a walk in place to idle.Select the any state to attack option,right click and maximize. And then fromhere for the condition, we want to say ifattacking is true.Now if attack is ever turned to false, wealso want to go back to this original idle state. So I'm going to right clickon attack here, make transition to idleand then for this

### Enemy Movement Using NavMeshes and State Machines

	In this video, we're going to explore how would you make our enemy move usingUnity's NavMesh system and how to use that in collaboration with the statemachine design pattern to enable our enemy to follow attack and die correctly.In order to implement our zombie behavior, we're going to need to diveback into code so with the zombie selected we're gonna go ahead and modifythe zombie behavior script. In order forour zombie to behave the way that we're expecting it to, we're gonna be using adesign pattern which is called the statemachine and specifically, we're going to create a finite state machine commonlyknown as an FSM within the game industry.This dictates, just like the animationsystem that anytime you can be in oneparticular state. So our enemy is eitheridle or it's following the player orit's attacking or it's dying, and there are a number of different ways that wecould implement this. But to know whatstate were in, we're gonna make use of aconcept which is called an enumeration. Now we already know that it's possiblefor us to use a bool for something beingtrue or false and an integer works forwhole numbers. What if you want to have avariable where there is one of fiveoptions you could potentially be. Now youcould have five bools for you know isidle, is following etc etc but then you have to make sure that you set all ofthem to fall, set the right one to true and it's a lot of work ahead of time.So instead, we can make use of anenumeration which is basically uscreating our own variable which can beonly certain properties being set to it.Or rather, an enumeration can only havecertain values being set to it verifyingthat every time we use it that is goingto be one of the options presented. Now to create one, we have to define whatthis new type should beand we do this by saying.So in this case here I am creating anenumeration enum calledstate which is public. Now within thesecurly braces we say what are the possible states we can potentially have.Well, we want to have the idle state,follow, die, and attack.And so the comma in between each ofthese sets this value. Now underneath thehood, the enum is actually an integer and if you highlight over here you'll seethat it says state the idol zero, follow isone, two is die, three is attack but thismakes sure that that number is always avalid state. And to create a variable oftype state, all we have to do is say public stateand then the variable name.We could even initialize it too.So in this case here, I know the state isstate.idle so that's the initial state.Now we need a couple other variables towork with when dealing with our statemachine. We need information like for instance you know, what object are wegonna follow etc etc. Now I'm gonna goahead and bring those in and we'll talk about them. Alright, so in this case the variables we want todeal with is how fast we want the enemyto rotate towards the player, how close should the enemy be before they followthem, and then how far should the enemy be from the target before it stopsfollowing it. Another important variableis the target which is the actual object that the enemy wants to follow as well.Back inside the Unity editor, take a look at the zombie behavior script and notethat because the state variable is anenum when we come back here, you notice the state is actually a drop-down. Andthose values that we set inside of ourscript are the only valid options that we have here. Now I've marked this aspublic to make it accessible for us tosee what state our character is in whilewe're actually playing, but in reality this would probably be private in thefinal version of your game. Now there's one more component that we need to addto our zombie before we beginimplementing our state machine. And if you go down to the bottom of your zombieobject, we're gonna add a component and this component is called a NavMeshagent. The NavMesh agent componentallows our enemy to move within ourparticular scene. In order for this enemy to be able to move, we need to createwhat's called a NavMesh and the waythat we do this is we first have to goand select our games environment, in thiscase it's just this cube here and we need to go and mark it as static. Andstatic basically just means that thiscube isn't going to be moving during gameplay, which means it'spossible for our AI to actually move throughout this environment. We're alsogoing to need to go and select window AIand then select navigation. And from here,you'll see that there's a section calledbake. This has settings for how far youwant your agents to be able to move, we're just gonna go ahead and hit thebake button. Once this happens you're gonna see this blue line around theenvironment. This is basically showingwhere it's valid for our AI to be ableto move. So with that in mind, let's nowgo ahead and dive into our zombie behavior script and start implementingsome of this behavior. To get started, we're first going to needto have a reference to our NavMeshagent component so we're going to goahead and add that. Now you'll see bydefault it doesn't know what the NavMesh agent is and that's because we'renot using the correct namespace for it.You'll see here if we add Unity engine.AI.Right here at the top, it will nowshow up and it knows what we're talkingabout. Now in order for us to implementthis, we're gonna make use of a conceptcalled a coroutine and a coroutine isunlike a traditional function. Inside ofC# and most programming languages, when you call a function you have to gothrough the entirety of the function before you can return to whatever calledthat function. A coroutineallows you to pause the execution of afunction in the middle of it go back and give control back to Unity for a periodof time and then come back, and thatworks really great for the finite statemachine pattern. To give you an example I'm going to go ahead and bring it inour idle state and then we'll discuss how it actually works.All right, so inside herethis function called idle state returnswhat's called an IEnumerator and IEnumeratoris a type. Unlike void, void isnothing IEnumerator contains information about the current state ofthe games for when we come back. Andyou'll notice that instead of justsaying return here, I have this yieldstatement, yield return zero. Yield meansgive back control to Unity and returnzero just means wait to the next frame.So from here, once we enter into thisidle state function, I first print out astatement that says idle enter. This means that we are entering the idlestate. This will only happen once eachtime we enter the state and these threelines are only going to happen once whenwe enter. Agent is our NavMesh agent isstopped equals true means that when we're idle we're not moving, we arestopped. I also am setting animation properties. I'm setting the speedvariable to zero which we talked aboutbefore and attacking is false, we're notattacking if we're in the idle state. Nowhere we have this while and this issaying while our current state is equal to the idle state, so as long as we're inthe idle state we check this functioncalled get distance is less than follow range. Now currently this shows up as redbecause the function doesn't exist yet, but get distance is just going to be thedistance between us and the player orrather the zombie and the player. And ifour player is ever close enough to the zombie, we change our state to the followstate. And so if we got here and we went back up to the top of the while loop,if follow equal idle that's not true soit's going to exit out. But otherwise we're just returning zero,so basically we are leaving the function,coming back and because we're in a while loop we just jump back to the top and wecheck, are we still in the idle state. And if we are, we keep doing this over andover again but when we're not we breakout. And in this case here, we say idle exit which means that we're leaving theidle state. And then I call a function called go to next state which alsodoesn't exist but return will cause usto start a new coroutine. So we're goingto first implement this get distance function and then the go to next state function.So get distance is just going to be returning the distance between us andour target and it's going to looksomething like this, right. I'm getting the length of the vector between ourposition in the targets position.And go to next state is going to looksomething like this.Go to next state is going to stop any coroutines if there are any currentlyrunning. It then creates a string withthe name of our current state idle orfollow and then the word state. We thenuse a concept of C# calledreflection in order to get a function ora method with this name in our project.And then I call startcoroutine with thatactual function and here I'm casting itas an IEnumerator. And again, this codeis all available in the example code forthis project. But in this case here when I call get method, it takes in twoparameters. The first being the name ofthe function and then any propertiesthat we want to use for it. In this case, we're looking for non-public functionsand instance functions. So with that inmind this will now compile and it willwork within the idle state but we're currently not actually telling thecomputer to follow us yet. So let's goahead and add the following state. So forour follow state keeps the same kind offormat. We have our interstate, our updatestate, and then our exit state and ourexit still calls the go to next statefunction. In this case here, while ourstate is still follow, we're stopping,we're setting our destination to thetargets position which is our playersposition. We're then setting the speed property to the current magnitude of thevelocity and we are setting ourattacking to false. Now if our playergets too far away, we set our state backto idle and then with that we just yield4.2 seconds. So every point two seconds we're going to come back and we're goingto check over and over and over again.And in this case, we'll either go followor idle follow or idle.So let's go ahead and save thisand we now need to actually set up howto make the player follow us or rather,how to make the zombie player follow us. And that's going to require us to setthe target property. Now the targetshouldn't be our cans right, it should beour players head, it should be our actual player. And currently we have noreference to that actual object so inorder to do this, we're going to createanother alias for our players headset.And so let's go ahead and go back,shrink the SDK manager shrink the zombie and go to our script aliases and we'regoing to create another game object for our headset. So I'm gonna right clickhere, I'm going to say create empty andthis time I'm going to say headsetalias. Now in order for the VRTKto recognize this, we're going to goahead and go to add component and we'regoing to use the VRTK SDK object aliascomponent. And then from here it's goingto ask what SDK object should this be.Under STK object, let's go ahead and say headsetand just to make sure that you are here,then go to the zombie and then drag anddrop to the zombie behavior the headset alias.And with that in mind, let's go aheadsave our scene. Lastly, we need toactually have it go to our initial stateso I'm going to go ahead and copy the goto next state function and then we're going to go ahead and call it inside ofour start function. So after we do all ofour initialization and we go ahead andinitialize the agent as well, we'll goahead and start this initial state. Andif we get too close, the zombie will nowstart coming towards us and he is comingvery very quickly. To make him less fast,so under the NavMesh agent let'schange the speed from a 3.5 to insteadbe a 1. And let's lower the accelerationas well to something smaller like maybea 3 and let's have it stopped before itactually gets to us, so let's say a stoppingdistance to maybe a 1.5. I'll then goahead and move him a little further awayfrom us so it's not as drastic at thebeginning of the project.And so now, as soon as he comes towards usand there we go. I think we'll also tweakhis size a little bit. If you'll look atthe NavMesh agent, it's a bit largerthen he's a little off foot maybe or thecollider is off foot. So I'm going to goahead and go to my collapse colliderhere and adjust it a little bit up. Allright. Next we can go ahead and add inthe die state or the state for being dead. So the die state here actuallydoesn't have a loop at all. The first thing we do is we stop the NavMeshagent so it won't move anymore. We saywe're not attacking and we say that we're dead. We print out that we're dyingin the console and we're going to destroy this game object after fiveseconds. So that way we see him on the ground and then afterwards he'lldisappear. Now to go to the die state we're actually going to need to modifythe take damage function. So we're goingto update the take damage function to the following. So in this case here, wehave the same function definition and we're subtracting the health but herewe're asking if our health is less than or equal to zero, we're just gonna setour state to the die state. And if we'renot dead, we're gonna still play the hit animation trigger but this case we'regoing to change our state to follow andwe're gonna change our following range to be within the following range of ourcurrent distance. And so now, if we startthe game and we're far enough away he'sgonna stop moving, and if we get closeenough he's gonna start following us. Andif we go far enough away where it'llstop following us, he'll stop moving.But if we fire at him, he's gonnacontinuously move and when he dies he'sgonna stop moving and then after fiveseconds he's gone. In the next video,we're gonna see how we can implement the

### Implementing the Enemy Attack State

	In this video, we're going to learn how to make our enemy attack the player aswell as how we can make use of animationevents to trigger functions through theanimation system, as well as how to have game objects send messages through eachother to other game objects. I'm going togo above the die state function and I'mgoing to go ahead and add our attackstate method. Now the attack state isfairly similar to other states that we've worked with in the past. First ofall, I set my speed to zero because ourenemy is a melee attacker and doesn'tmove by default while he's attacking. Ialso said that the attacking bool is nowset to true, so now we will transition tothat attack animation. Now while ourstate is in the attack state, so Unity'sNavMesh system only rotates an object ifit is moving to another location. Sowe're going to have to rotate the character ourself and so we're going tocall a function called rotate towardswhich we will have to write ourselves. Now you'll remember that the NavMeshagent has a property called stoppingdistance, which is how far it goes beforeit stops. So in my case I'm saying if mydistance is greater than that stoppingdistance plus 1, so if it's further than that stopping distance we're going totransition back to the follow state, and then we're going to wait to the nextturn keep doing it over and over andover again. And the attacking itself is going to be taken care of by theanimation state machine. We're also going to call go to next state whenever wechange what state were in. So we're going to need to implement the rotate towardsfunction which is going to require alittle bit of vector math. And so here iswhat it's going to look like. So first ofall we get the direction in which we are trying to rotate towards, so thedirection from us to the target. And thenwe get in the look rotation which is going to give us a rotation given theforward in that direction, so we're looking in the X and the z axis here. Andthis is basically just gonna flatten the vector so it's easy for us to know. Andthen we're setting our rotation to thereturn from this function called slerp,quaternion dot slerp and slerp standsfor spherical linear interpolation. Ittakes in three parameters, the first is what is your current rotation, the secondis where do you want to look and thenthe third is how far should I rotate towards that. So it's going to move usover a certain period of time and here we're using that rotate speed variablethat we created earlier on in the class.All we need to do now is add in theability to go to the attack state. Sowe're going to transition over to our follow state method and after we checkif it's greater than the idle range, we need a check if we're close enough totransition to the attack state. So that'sgonna look something like this. Here, wehave two conditions. First of all we areasking if our current distance is less than or equal to our stopping distanceplus 0.5, just so there's a little bit ofleeway room and our NavMesh is complete,it's finished moving. So if both thoseare true then we're going to transitionto the attack state. So I'm going to goahead and save the script and now we'regonna dive back into our game. Alright, sowe currently have the enemy walkingtowards us and if we get close, there it is. It's playing the appropriateanimation, the attacking animation andthat's pretty scary. And if we are to move away,it'll transition back to its followstate. And if we get so far away, it'll goback to idle. So now we have it so the enemy isactually attacking us but there's noactual feedback from us taking damage, and that's because we haven'timplemented that yet. However, we can implement it fairlyeasily. So if we go to our headset aliasobject here, right now the only thing we're doing here is we have the alias ofwhere we are. You can also add acomponent for our actual player. So I'mgonna go ahead and go to project here and we're gonna go to our FPS gamescripts folder and gonna create a new script which I'm going to call player behavior.Create C# script,capital P capital B and no spaces.Then we enter this. So from here,we're gonna go ahead and create a couple new variables. Just like we did before,we're gonna have a public int for health,we're have a private int for the currenthealth. In start, we're going to set ourcurrent health to the value of healthand we'll initialize health here to one hundred.Now we don't have anything for update herebut we are going to create a functionwhich is going to be called take damage.So if we'll note this looks fairlysimilar to what we wrote previously,current health minus equals damage todeal. And then ifcurrent health is less than or equal tozero, we are going to print outgame over.So we could also restart the level by calling the scene manager dot load scenefunction and we can use the currentscenes name. Now in order for the scene manager to show up, we also need to add 8the using Unity engine scene managementnamespace. All right, so we're gonna goahead and save this and we need to havesome way for us to call this particularfunction. So let's go into zombie behavior,we'll reload here and we're going to adda new public functionwhich we are going to call withinanimation within the attacking animation.And we're going to call it physical attack. We're also going to create avariable for how much damage we want todo to the player, which I'll just set to 20 for the sakeof demonstration. And what we'll do is basically say, ifthe player is too close to us we want to damage him. All right, so this lookssimilar to what we've done before. If the distance between the zombie and theplayer is less than the stopping distance plus 0.5, so if we are closeenough to take damage then we are goingto call target dot send message. And sendmessage takes in three parameters, thefirst being what function should be called and this is going to be a string.This also makes use of reflection likewe saw previously. The second is whatvalue if any should be sent to thisfunction and the third is the sendmessage function calls this function onevery component that is attached to thisgame object. This here says, hey if thiscomponent if a component doesn't havethis function don't give me an error. And so with that we're gonna go ahead andsave. So now we have this physical attackfunction but how do we actually call it. Well, we are going to call it through ananimation. So let's go ahead and selectour zombie here and let's open up theanimation window by going to windowanimation animation.Now this will give meall of the information of the animations that are playing inside of our project,and if I hit play here you'll see that'swhat the idle animation looks like.Now, I'm going to unplay this but under this drop-down here we can change fromidle to all the other animations thatare part of this character. Of course, oneof them is attack. If we go here, you'llsee that the zombie is attacking andwhat we'll do is when the zombie putsits fingers out like this, we will callthat physical attack function. And we cando so by this button here that saysanimation event add event. Click this andyou'll see that it's asking me whatfunction should be called and this will be any function that's public that'sattached to a component on the zombie. Soyou'll see all of our states, you'll alsosee the physical attack function and we'll do the same thing through thisanimation. You'll see it goes down onemore time like here. We'll go ahead and add another event,call the physical attack function. Solastly we're going to need to add theplayer behavior to our object, so I'm gonna go ahead and drag and drop playerbehavior onto our headset alias here. Andnow if we go ahead and play, we are nowhaving him come close to us, he isattacking and if we take too much damageit restarts the scene.So with that, the attacking is now workingcorrectly. In the next section, we'regoing to learn how we can create levels for our characters to interact with aswell as how to build them specifically

### Importing ProBuilder

	Building levels for VR. Level design isone of the most important aspects of allgames but are critically important forthings like VR. Being able to createenvironments that work with scope, thatfeel like an actual environment you eventually be in while also guiding theplayer where to go, while also making itnot obvious that you are telling them where to go is an art as much as ascience. And there's a lot of informationthat we can be particular topic, some ofwhich can warrant an entire book just adedicated to doing level design. Well we can't talk about every little thingwithin this video series. I think it's agood idea to get an idea of how to buildlevels quickly to then be able toiterate upon them and create interesting events, which is what we are going to betackling in this section. In this firstvideo, we are going to be learning how toadd the ProBuilder package to ourproject. ProBuilder is an excellent toolfor prototyping levels and allows you togenerate geometry for a level withouthaving to dive into another third-partysoftware like 3DS Max, Maya or Blenderand still create an environment that canbe quite interesting. Now before we can actually use ProBuilder, we have toactually include it inside our project.Now ProBuilder used to be a asset that you would have to download from theAsset Store but recently Unity haspurchased the team that worked on ProBuilder and so it's possible for us tojust add ProBuilder to our project, making use of the package manager.We're brought to the following window.From there you'll see a large number ofavailable things that we can use with our project.One, we can either scroll down to be able to find it here or in this case you'llsee ProBuilders here or you can click up here at the top and start typing inthe word Pro, and you'll see it here aswell. So once this has been selected, goahead and click on the install buttonand it should add everything that weneed to the project.Once it's finished downloading, you should see a little check mark to theright of its name and just to verifythat it is working, we can close out ofhere. And now you should be able to go totools and then under ProBuilder, youshould see a section called ProBuilder window.You should see something like this pop up and if you do, you'll know thatProBuilder has been successfully installed. In the next video, now that we haveProBuilder installed, we are then going to learn how we can actually create a

### Greyboxing a Level with ProBuilder

	In this video, we are going to learnabout ProBuilder's interface, how toattach it to areas on our screen, how towork with it, how to create shapes, how tobuild rooms. All sorts of fun stuff tohelp you do what's called a greybox, which is often the first stage of leveldesign where you're not focusing onmaking something pretty but just gettingbasic shapes, typically boxes out in theenvironment and play testing it to makesure that it's engaging and it's fun towork with. One of the the first things to note about ProBuilder is that even though wehave this as a new window like this, it's detached from Unity but we can actuallyattach it anywhere in the editor we want. So for instance, when you click and dragthis and we can move it to latch it hereor above or replace whatever's herebefore. I think I'm gonna go ahead andput it here on the left hand side.You'll also notice that currently thisis a set of text options but if youright-click outside of the windows here,you'll see if there's an option to use either text mode, which is what we'recurrently using or use icon mode. Andinstead of text, we now have these asimages and if you move your mouse overany of these it does display what it is. You can also access the menu by clickinghere and you can also select it from here. I'm gonna go ahead and use the textmode because that's the one that takesup the least amount of space. Now the first thing that we're going to probablywant to do is to replicate what wealready currently have. If you'll notice on the bottom our screen right now wehave a floor and the floor is currently,if I select the cube object a 25 by 25by one room. It's already located hereat 0 0 0. Ok simple enough. I'm gonna go ahead and delete thisobject and we're going to instead makeuse of ProBuilder to build this. To getstarted, we're gonna make use of the newshape menu. Now if you click this byitself it will generate a box andthat'll be fine but I'm gonna go and delete this by hitting the Delete key.But I want to show you that if you hit ctrl shiftK or if you click on this little plushere, it'll bring up the shape but it'llalso bring up this menu. Now this menugives us two basic options. One, we canselect a shape that we want to use. In this case, we're gonna still want to makeuse of the cube that we've already been using so far. But there's also a propertyhere for the size of the object. So justlike our original cube was 25 in thex-axis and 25 in the z-axis, we can dothe same thing here and once I click thebuild button, you'll see that it now exists. I'm gonna close this outand let's make the cube go back to zerozero zero and you'll see that, unlikewith our previous example the center of the object is actually halfway throughthe object. So for position to be working correctly, we'll need to make ourposition negative twelve point five andthen twelve point five.I'm gonna go ahead and say negative 0.5and now when we run the game, perfect. Buteverything that we've seen so far has been basically the same thing as anormal cube. One of the advantages that ProBuilder has over the regular genericUnity objects is the fact that we canactually modify the individual vertices,edges and faces that the objects that wecreate actually have to them. Now one of the ways that we can see this is ifyou'll notice in the top section here, when we have a ProBuilder objectselected you'll see that we now have these four options. Now this first one isthe object selection but then there's avertex and then here's edge and thenhere is face. And you should notice that when you click on any of these sideswith the cube object selected, you'reable to work or you're able to transformor rotate or scale.Now this is incredibly powerful and I'mgoing to click and drag so that this ishigher than our player. And if I holddown the control key while this is going on,notice how this snaps. So I'm going to go ahead and keep the snap like holdingdown the control key and I've made this you know it's a box it's currentlycovering our zombie. But if I go aheadand I select the vertices of this objector rather the edges of this object, you'll see there's an option here whichis called flip normals. And if I clickflip normals here,notice how it's just flipped the normalson each of these different vertices. So if we go ahead and we play the gameright now and you'll notice we'vealready been put into an environment that looks like a room. And this is areally easy way to create a room insideof your project. Now notice that the character currently doesn't movecorrectly, that's because the navigation has been changed. It's now half a unitlower than what it previously but thisis a quick way to just get a room up real quick. I'm gonna go ahead and undothis though, I'm going to go ahead and make ctrl zuntil we're back to this point. And go backto face selection and again notice thatwhen I click and drag along this edge here, I can resize the environment pretty quickly.Four is something similar to subtractivegeometry, which is where you're building a large we were basically building theboxes of the environments that you're in. What I generally suggest people do is,especially when learning how to work the level design at the beginning is tobuild things using additively. And one of the reasons for that is that you aremaking more objects but you're also making it much easier for you to be ableto tweak in the future. If you decide you want to make rooms bigger or buildingsbigger or things like that, you don't have to worry about dealing withdifferent normals and things like that. So we're going to create this room inthe following way. I'm gonna click and drag this area, click and drag the edgesof my walls to get them however big Iwant this environment to be. In this caseright now, it looks like we're 12 by 1 by22 due to what's being displayed here.This is a read-only value but it tellsus how big this actual object is. And I'm gonna snap this here,let's go 12 by 12 12 by 13 sure. Drag onemore out 12 by 12 cool. So this area ismuch more condensed than what we hadbefore but we can easily make us intoanother room as well. I can do this by going switching to the object selectionmode, selecting the top section here andthen we're basically going to duplicatethis mesh. So if you hold ctrl D and thenit's been duplicated so we can move it above and there we go. There we go, I'vemoved it so it's 3 units above what was there before and just to make it easy tosee what's going on here, I can go ahead and click on the light section here toturn off the lighting in our level. We'll talk about how to light our environmentsa little bit later on while we're working on the project.Now once we have this going on, we needto actually complete the room and this brings me to one of the other coolfeatures of working with ProBuilderwhich is extrusion. So if I go ahead and click on the face tool again and Iselect one of these edges here, if I canselect multiple edges by clicking outthe control keyand I can also if I say select face ringhere, this will also select everythingnext to me without having to actually gothrough and do it manually. Once I've done this, I can go ahead and use theexclusion. Now you'll see that these options have different colors associatedwith them and so in my case, we're goingto select the extrude faces which is actually modifying the mesh which is whyit shows up as being red here. Now I'm going to click on the options here andit brings up a menu that shows that hasextrude by face normal or a distance, which is how long we want this to bepulled out by. I'm gonna go with onebecause I like working with big numbers at the beginning of my projects and thenlater on I can shrink them down, but this is basic going to take all four of theseand create a new face or new faces thatwill face out from where this was selected from. So when I click extrudefaces here, notice that it just generatedin every directionone unitin that area. Looks like that last onewasn't selected here, so I'm going to go once again have everything selected andI could just click extrude faces and itwill use the options that I set the last time through here. I can also createextrude these by myself by holding downthe shift key and when I do this, holddown the ctrl key as well and you'll seethat it snaps. Now in this case here, I'm going to select this side, also shiftclick snap and do the same thing for theother four sections as well.And by clicking on the heads here, goahead and move this up there we go, and I'm gonna go ahead and hold shift oncemore one two three and we've enclosedthis environment all inside a box. Nowagain, if we go ahead and turn on lighting not gonna see anything in here.We're gonna have a whole section on lighting later on in the project butjust for the sake of being able to display something, let's go ahead and goto game object light and then select apoint light. And if we turn on the lightsagain, if we move this object so that'sactually inside of the room. You're on object selection here, we got the light,let's go ahead and move it over and now if we go ahead and move this around,let's go ahead and play the game.All right, so nowlooking good. Continuing with this is actually quite easy. Let me go ahead andshrink up everything here and our roomis just single cube here, which is thefloor and walls so let's say roomand the top is our ceiling.So I'm going to select both the room inthe ceiling and the point light as well,and I'm just going to hit control Dand then drag this over to a new area.Now, I could just have it be a straighthallway or something like that but forour purposes I'm going to put it likethis way and I'm gonna make it go overthis way as well. And what we'll do is we'll effectively create a hallway thatgoes in between these two rooms. So thequestion is how do we go about doingthat. Well first of all, I'll go ahead andsnap these together and what we effectively want to do is we want tomodify or we want to add a way to gobetween these two areas. Now in the top right here, you'll see the cameracontrols and if you click on any ofthese it will move the camera in thatparticular direction. And if you clickthe center option for a second time, thisgoes from perspective mode intoorthographic mode, which basically just means that it's straight down so it'seasy to see where things connect and whether they don't. Oh and what we'regonna do here is we're gonna create another shape that will create thisactual hallway. So I've got this new shape here and it's been placed and weare going to tweak it. And I couldcontinue to work with the face mode but then I would be forced to move aroundthe world here. But this is where the vertex selection mode becomes that muchmore powerful. I'm gonna go ahead and click and drag to select two of thesevertices at once. This is called amarquee selection. Now I want to point out that if I do move the camera downright now, if we do want to select all four at once what we have to do isunderneath here there's a selection called select hidden. Right now it's setto OFF, if we click this it'll be set toon and now if I click and drag here,you'll see that indeed all four are nowselected. Now once this has happened, Ican go ahead and click and drag here andI'm gonna hold down control again so that we have aof four of these guys to work with. And I'm gonna go ahead and select the objectmode again to move it a little bit slightly up but you'll see here thatwe've got ourselves the beginning of apossible floor. And I'll just bring it down. An easy way to get this to work isjust by dragging like here so again you see we're getting to the bottom of thefloor here. And I'm gonna go back to vertice mode, click and drag the edge.Again, notice it's selecting all fourhere and I'm going to drag out fourand what we're gonna do here is ProBuilder doesn't actually allow us toextrude edges using vertices, so I couldeither go here and go to face selectionor I can just select this object. Hitctrl d, drag this over and then we canuse the vertices here to just click and drag and then complete this hole here.And so now we've got these areas but wedon't have a way to walk through and that's what we're going to start divinginto some experimental tools. So I'm going to go ahead and turn off thelighting here again and you'll see thatwe currently have these guys.If we're back in perspective here, you'll see that we currently have these goingthrough and what we want to do is weeffectively want to have a wall in this area.What we will do is we will create ablock which would be the size of the door that we'd want to go through here.So one of the easy ways to be able to do that real quick is if you have a cube,well we can just duplicate it ctrl D andthen I'm going to just grab the facesreal quick.Make it so it's only one hi here and I'mgonna select on this new object our cube2 here. Let me go to object move modehere, we'll move it over and we willposition it so that we can work with ithere. So in this case, I'm going to makeit taller on the face mode so we're gonna go to the top here. We're gonnaselect the face, move up three and thenwe have to shift it down so that it willactually move throughout here. Now I'm gonna go ahead and go to that selectmode here and if we go into object mode,we effectively want to create a holebut it looks like we're about one half tootall here. So I'm gonna go ahead and setmy Y here to 0.5 so we're at the samelevel as here. And we are going to makeit so this face is a little largerbecause what we're going to be doing iswe're effectively going to put this as a wall between both of these objects andwe're going to make use of somethingcalled a subtractive brush. So if we goto tools ProBuilder, there's a section here called experimental and thenthere's a section called boolean CSGtool. Now this will ask you to providetwo different game objects. Now thesecond is going to be our hole here soI'm going to go ahead and call this holeand that's gonna be my second object. Andfor the first object, I want it to be myroom. So we've got the room and we've got this hole and what we want to do isunder operation, we're gonna choose asubtraction. And what this is effectively going to do is it's going to look atthis object and anywhere that thisobject intersects this object, it's goingto generate a hole. And when I hit apply,you'll see nothing appears to happen just yet but you'll notice that there isa new game object that's been created.And if I take the hole here and I turnoff the holeand I turn off the room, you'll see that there is now a gameobject has been generated that has thisexact hole that we're looking for. AndI'll go ahead and move this guy a littlebit down as well. We're gonna move itdown to fit this side here which Ibelieve is a negative 0.5. Looking goodand at that point we've got ourselvessome flush wall here. And we'll do thesame thing for this side as well, so under transform under Y we'll saynegative 0.5. And what we'll do is weneed to add a hole for this side as well.So we can go ahead and do the same thingagain we can go ahead and just grab ourhole that we made previously and we could duplicate it, rotate it, bring itdown here. Or we can just grab this wholenew game object itself and duplicate it so I think that's what we'll actually do.So I'm going to go ahead and delete this and we'll keep the ceiling for right now.But let's go ahead and rename this to room 1,duplicate it, control d. It's room two nowand if we move up to the top here,let's go ahead move it over, hold downcontrol like usual, control move it over.And under rotation, we will also hold downcontrol and rotate it around and so nowif we scroll on over,looking pretty good. Looks like there's alittle hole here, let's go ahead and fix that real quick go to our transform tooland we will shift it over.I can see it 17and all goes well. Looking pretty good. Solet's go ahead and run the game now.As you can see,we've got this room that we can movearound in. We can teleport through, wecan't teleport into the void but we canenter into this other room. You maynotice that when we ran the game, the world didn't seem to really want to teleportwithin our rooms. And it appears that dueto the experimental nature of the ProBuilder there, the ProBuilder meshes forour subtractive rooms do not actuallycontain mesh colliders. So we canactually just go ahead and click on addcomponent and select mesh collider, typein mesh, you'll see mesh collider andwe'll do the same thing for room 2 here.And one last thing also we need to do iswe need to mark all these objects asbeing static, because we don't want themto move and we can update our NavMeshby going to navigation and thenselecting underbake select bake. And nowour enemies should be able to walk anywhere within these two rooms, and infact we might move the zombie to be a little further out so that the planedoesn't immediately start with the zombies actually there yet.So I'm going to go ahead and go to the inspector here and drag the zombie outjust a little bit, and let's go ahead andplay the game one last time. All right, sowe start the game and we're within this one room. We're able to move through itcorrectly and if we get close enough toour zombie here, good stuff. And we're able to movethrough here but not in the void and wecan move to the other room with ease as well. It does look like there's a littlebit of a indent or a gap here so let'sgo ahead and fix that real quick. Withyour ceiling tiles selected here, go ahead and move to object mode and holddown the V key. When you do this, clickand drag to you reach this edge here andthis will make it so that the ceiling and this room itself actually fit each other flush.Looking good. In the next video, we aregoing to be assuming that you've come up with your final greybox level andyou're ready to make it feel a lot morelike a real environment. We're gonna step into those roles of an environmental

### Applying Textures to Environments

	In this video, we are going to step asidefrom the role of a level designer andmore into the role of an environmentalartist. We've effectively finished up ourgreybox, we play tested it, we made surethat it was perfect and now we're goingto add in some arts. We're going to learnhow to work with materials using thematerial editor as well as how to useProBuilder's UV editor to customize thesize and various aspects of the UVs onour object. At the very end, we'll alsotalk a little bit about how to addmeshes to improve the visuals of ourscene.Now once you've built out the level toyour final specifications, the next thingthat we're going to do is actually makethis look more like a final version ofthe game by actually adding colors andtextures to this actual environment. Andwe can you know, there are entire classeswhich are just on the ability ofcreating art assets for games so wedon't have time to dive into that.However, we are gonna make use of a freeasset from the Asset Store that we canquickly plug into our projects to getsomething that we can look at real nice.So I'm going to go ahead and go to theAsset Store and from the search bar,we're gonna go ahead and put in horrorhospital. So underneath our search herehorror hospital and let's maximize thisreal quick.You'll see here I have this horrorhospital pack. Now it's completely freeto use and if you click on the downloadbutton here or import, it gives us anumber of new things we couldpotentially work with. So let's go aheadand click on import.It says that there's an API updaterequired, go ahead and say that you'vemade a backup.So once it's imported we'll close out ofthe Asset Store and you'll see a newfolder that's been created called horrorhospital pack. Now inside there you'llsee a demo scene but you'll also seeprefabs, models, and materials. Now in ourcase, we look at the prefabs. You'll seethere's a number of meshes that we canplace into the world itself but thething that we care about right now arethe materials.Now under the materials, there's twosections one for floor which has aconcrete material and a floor materialand sill, which is the the ceilingmaterial. So with that in mind, we've gotour floors and if you go to the modelsfolder you'll see it there's folders foreach of the different models that existhere including the wall folder. And inthe wall folder, you'll find anothermaterial which is for the walls of thislevel. Pretty cool. So first of all let'sgo ahead and look at the floor here. Nowadding materials to ProBuilder objectsis actually quite easy if you want thewhole mesh to have that particularmaterial. So for instance if I click theconcrete here and drag it over an object,notice that it will color the entireobject that's been given to it.Now that'll work fine for our twowalkways here right, but it's a littledifferent for what we want to do forthese buildings themselves. But you maynotice also that's very easy to see thisduplication of stuff inside this actualtile, and that's because this defaultmaterial is actually quite small. So wemight want to fix this, so if you selectthis object or actually we can selectboth of these objects. You'll see thatthere's an option here called the UVEditor. If I click the UV Editor, thatwill bring up a menu that looks somewhatlike this. And when I have these objectsselected, you'll see that these get drawnout. Now it might be a little easier ifyou see me select the faces but if Iselect one face on here, you'll see yepthere's one face that's here as well. Nowif I have all these faces selected,you'll see there is a section herecalled tiling and right now it's set to1 1. And you also see visually this isthe size of one of those materials, whichis actually quite big for this case. Nowif I set this to be two, you'll seeit's half the size that it was beforeand you may notice that if we look atboth of these, this looks less repeatedthan this one. But we can actually takethis yet another level, let me go aheadand select the whole object again. Goahead and face selection again. I can goto be four or even eight and if I doeight, you'll see that it's much harderto tell that that duplication is goingon. Let's go ahead and select this guy aswell and ctrl-a doesn't work, so I'mgoing to go ahead and do a marqueeselection on these as well. Click anddrag them out and when I have all theseobjects selected, we'll just go ahead andsay the tiling is eight again. Now againthis makes it smaller and if we move onin, you'll see it automatically looks awhole lot better than what was there forus previously.Now this becomes a little different whenwe try to work with this room itself. Now,by default if I select one of thesevertices, because of how we split this upusing the subtractive brush we no longerhave that nice floor. And in fact if I gointo the UV Editor, you'll see that it'smuch more complex than what we hadpreviously. But under here you'll seethat there's a section which is calledgrow selection right here, and thisallows me to select all the adjacentelements and by default if they'rewithin a certain angle, they will selectthem. And by default if I hit plus here,that angle is 15 so when I click on thisbutton it selects the entire floor herefor me. And so if I go ahead and go tothe UV Editor again, you'll see that it'sall selected as a single floor. I candrag it out to make it easier todisplace or make it easier to look athere. And I can go ahead and go to myscale tool here and drag this down likethis if I want it to be be smaller.They'll scale all separately.But if I change the mode here to groupselected faces, when I do that now you'llsee that they all scale together rightnext to each other. And so if I were forinstance, let's go ahead and assign tothis object a material, I can do that byselecting the material editor and thenyou'll see underneath here we have thissection called quick material. If I go tofloor here and I'm going to select thefloor material and if I press apply,you'll see that indeed that is beingused. But like we mentioned before littlehard to see. So in the UV Editor onceagain, let's go ahead and set it to eightand yes already this is a whole lotbetter for us to be able to work withhere. Let's go ahead and do the samething for the walls for this as well. SoI'm going to go ahead and select a growselection again, grow selection andwe've got those selected. Let's go aheadand add that as well and this is wherethe other section of the material editoris going to come into play. If you noticehere, there's a second section which iscalled the material paletteand if you drag and draw a materialinside there. So for instance let's goand select the wall and drag and dropthe wall diffuse material in here. If Ipress the alt in two buttons, you'll seethat it automatically will add thatmaterial to this particular selection. Now you'll also notice that it's alittle hard to see here, the material isactually a little small then it shouldprobably be but we can also fix that aswell.Let's go ahead and go to the UV Editorand so just like before, we don't wantthe scaling to go like this so we'regonna go ahead and make sure we setgroup selected textures or rather groupselected faces. Now the other thing wewant to do is it's often the UV Editoris nice but it's also nice to be able tolook at this and to make modificationsbased on this as well.If you click on this button right here,this allows you to make it so thatinstead of modifying things in in here,you can actually modify them inside ofthe Unity inspector as well.Goes to scaling here and we are going toscale thisupso it's a little easier to work with, andwe can make use of the transform tool tomove this up or down however we need itto be.And with that we've got one perfect wall for us to work with here andbasically, what we're gonna do at thispoint is we're going to effectively dothe same exact thing for all of theseother walls. So we're gonna go ahead anddo that now,grow selection again, alt 2. We'll goahead and see this is currently a pointthree two one one one so we'll go aheadand use this grow selection. We'll goahead and go here, group the faces and doit again. Looks good and if I go herelooks like they're matching alright andwe'll do the same thing here, growelection. I can go here, grow selection,will group everything like it was beforeand we'll paste it up.And so with that, we now have this partof the interiors done. Let's just do itone more time, let's grow the selection.So go ahead and select this again, UVEditorand there we go. We've got these facesworking correctly.Looks like our floor got messed up realquick, let's go ahead and fix that, growthe selection and we'll go ahead andgive that our floor.If we want to go ahead and give ourceiling a material as well, we can do so.Go ahead and select it real quick. It'sjust a single face, we can put theconcrete material on that. Looking good.Let's go ahead and resize that as well.So we go the UV editor and just say 8 andwe should be good to go. So now we needto decide what we want to do for theexterior of the room and for that, I'mgonna go ahead and make use of thematerial editor again. This time I'm going toadd and for to all three, I'm going to goahead and use the concrete material. Somconcrete here. I'm gonna close this out, I'mgoing to have the UV Editor also closed.And so now I'm going to just go aheadand click grow selection, grow selectionand then I'm gonna hit alt 3. And noticethat it only modifies the selected facesI have here. Again, grow selection. I canalso hit alt G, so I can just hit alt Galt three and here all three. And we justkeep doing that for the rest of thisobject here, so I'm going to go aheadalt g 3.And if we select multiples of thesefaces, when I hit alt G it's going to doit relative to both of these. So I'mgoing to alt 3 here as well and again,we're just going to do it for everythingelse. Socommand for each of these walls. Sobasically we just need to select onething from each wall here, so controlcontrol controlcontrol control control controlthen control control then alt Galt three.And not too shabby. Let's go ahead and dothese faces real quick so alt g alt 3.Not worry about the top here. This willactually probably want to use thisceiling instead but we could do alt Ghere. And then when I go to the sil, thesil ceiling will go ahead and dragthat in.And we'll do the same thing over herefor this side so alt g alt 3.And you'll notice that there's thisconflict here. Because there are twomaterials the same z-order at the sameposition, that's what this is showing upfor. There's a couple ways that we can goabout fixing this but a quick solutionwould be to just grow the selection andwe can actually delete this note. We canalso select this,alt G to select multiples on here and wecould actually just move this slightlydownwards.And you would see that the other objectwould overlap it instead. So if one ofthem is set that way it should work outokay. Or we can just select all the facesand apply a material to it, so forinstance alt three.So again, you'll want to play with ituntil you find where it is that you wantthis to look like and then finally, let'sgo ahead and finish up the ceiling here.Let's go ahead and just drag and dropthe sil texture on the rest of this guy,it's good object mode. Well sil, allright looking good. So we can go throughand we could do everything that we didhere to this one as well or we can justduplicate it. So let's go ahead and dothat and in fact, why don't we go aheadand select our room 1 and our ceilingand our point light here. And let's goahead and make this a prefab. So I'mgoing to go ahead and create. I'm gonnatake the ceiling and the point light, makeit a child of the room and then underprefabs for our game, we'll go ahead andmake the room itself a prefab. I'lldelete this other point light, not neededanymore but then we'll just drag anddrop this room and then we can justposition it as needed. So go isometricmodeand we can just rotate. Let's turn onlighting so we can kind of see what'sgoing on here. And we will shift it over,shift it down andexit isometric mode.Off lighting, we'll need to rotate thisreal quick easy enough.There it is and if we shrink it down.Again remember we can use the V methodhere. So if I go V and I select thebottom of the door here and I drag it tohere, you'll see that it snaps to fitthis doorway.And we'll go ahead and fix this guy realquick.Let's go faces selectalt g alt 3, beautiful.All right and we'll do the same thingover here as well,alt g alt 3. And so now if we goahead and we dive in the game, we shouldsee it with different materials. Alright,it looks like our old the code that wegot from the cross-platform input isbroken but that came from our assetshere. We don't actually need it so we'lljust go ahead and delete this folder ordelete this script, because we don't needit because we wrote our own thing. So nowwe go to the console,no more errors so with that let's goahead and play. So our environment isalready much more believable for us tobe in. I can go through, we can go throughthe environment, looking good and lookinggood.So with that, we now learned how we caneasily add UVs as well as othermaterials to our walls. Also, before thenext video feel free to go to theprefabs folder and in each of the rooms,feel free to drag and drop some of theitems in there to make the scene seemeven more realistic and interesting. Soyou can throw things like a stretcher, abed but place them in such a way that itkind of makes sense for the environmentthat you're trying to create. In our case,we are probably not having them fill upthe room too much but it will add someadditional details and make the roomfeel even better.My final version looks something likethis with a little bed and a stretcheron this one and then a couple of cartsand a door and some other stuff in thisone. Now in general, I had to make these alot smaller than what they wereoriginally brought in with and you cando that easily by just selecting theobject and then using the scale tool andthen clicking and dragging as needed andthen moving it down. In the next video, weare going to touch on all the differenttypes of lighting inside of Unity whichis useful for VR development and see howthey can affect our scene and how we canmake it fit our horror zombie game inthe best way possible.

### Effectively Lighting Your Scene

	In this video, we've previously touched a little bit on lighting in the past butin this video, we are going to learn about the different ways that lightingcan be affected in our scene and how wecan adjust the visuals of our level veryquickly by just using a simple view lights. We'll also see how we can uselights to create gameplay elements, suchas adding a flashlight which will allow our players to dictate where they wantto see things on the screen. So at thispoint, we have our level finalized. It's been greyboxed out, we've added materialsto it, we've added meshes to make theenvironment come alive. Now we're gonnadive into the world of lighting. Now we've talked a little bit about somelights that exist inside of Unity already. We've talked about the pointlight which effectively is like a lightbulb. It has a range and a color and anintensity. You'll see these yellow lines,this is the range. The higher it is the more it's going to draw, the smaller itis the less it's going to draw.The intensity itself increases how muchlight is actually going to come off ofit or not. And the color modifies howit's going to display and the color of course looks like this. You can modifythat as well. Transparency does not do anything withthese lights though, just something tokeep in mind. Now the main lighting thatwe're seeing from the world right nowcomes from our directional light. Now thedirectional light, you can see right here and the directional light is this guy right here.Now the directional light, it does notmatter where in the world this actualgame object is. It doesn't modifyanything that we see and that's becausethe directional sight acts like the Sun.And it doesn't, the Sun is infinitely faraway but the rotation that it is towardsus modifies how things get drawn. So if Iwere to change for instance the rotation of my object here, you would see doesindeed change how things are being lit.And in fact, this is being this isworking in conjunction with this whole area which is called the skylight.Now the skylight details can be found ifyou go to window and then you go to rendering and you go to lightingsettings. Now, with the lighting settingsit'll pop up and like this and you'll see that there's a section for alightbox material. It's using the default one but there's also a section for a sunsource, which is what it's considered to be the Sun. There's another sectionhere called the intensity multiplier, which if you turn it higher willbrighten stuff and if you lower will lower stuff. And so for instance, if I hitgenerate lighting here with a higherintensity multiplier we will potentiallysee more data here. Now you'll noticethat's taking quite a bit of time for it to bake this lighting, which is why in generalis we typically will turn autogenerateoff earlier. As you can see by thefinalized version here, you'll see thatit does greatly increase how high or howbright the intensity is going to be. Butwe are creating a horror game or a gamerather that had zombies and horror elements in it so we probably don't wantto have as much light on the screen. So one of the ways that we can do this isby lowering the intensity multiplier sothat it's very small or zero or in ourcase, let's say maybe a point one. In addition, we can also change thedirectional light so for instance if Igo over here and we select the item, I'm gonna go ahead and change the X rotationof the object so I'm tilting it upwards.Now what this effectively does is it'llchange it so that it seems like it's in the night and we're going to move itslightly up like this, and the sky boxitself will automatically update basedon the values from this. And so if wewere to jump into the game right now, you'd see something like this. All right,so because of the point lights we'restill able to see inside of thisenvironment inside this room but if wemove on forward out to the dark area here, you'll see that it's pretty muchpitch-black and we can barely see thezombie in the distance.And so at this point, we should be ableto teleport into the other roomand we should be able to see it as well.And so again, we're going for more of ahorror experience so another thing that we can do is we can take away theselights or lower the brightness of them and instead make it so the player canuse another type of light, the spotlight in order to use it like a flashlightthat the player can move around with. Solet's go ahead and select the point light inside of the room here and I'mgoing to go ahead and turn down its brightness so its intensity is only at0.1 here, again very low. I'm gonna thengo ahead and go to the room object andapply this change to the other prefab bygoing to overrides and then I'm going to go ahead and turn to all. That's going tomake all the changes we've done to this object happen to the other one as well.Afterwards, let's go ahead and go back tothe prefabs folder and double click on our handgun.Now with our handgun, we are going to addanother child object which is going to be another kind of light. So I'm going toright click on the handgun here.We're gonna select light and then underthat we're going to select spotlight. Nowspotlights are as you can see from thisvisual right here, it is a light thatstarts from a singular point and points outwards much like a spotlight in reallife. We want to have this to have avery long range, the range is how far it's going to draw out at. I'm going togo ahead and give it a range of let'ssay 50 here and we have a spot anglewhich lets it draw out more or draw less. Let's go ahead and see what this lookslike to begin with at the original 30value and then there's a color value which is what color you want this to be.Now because this is emulating a flashlight, I'm going to give it a littleoff light off yellow vibe to it and wecan bring down the intensity if we wantto maybe a 0.75. And let's go ahead andplay the game and see what happens whenwe bring out our hand guns.All right, so you can clearly see nowthat with our gun it actually matchesas a flashlight as well, and if we shineit over things we can actually see it.And if we teleport over, we can see thezombie, we can shoot him down and we canalso see around the environment as well.And through here, we got ourselves a muchmore horror game kind of vibe to things.And with that, we've touched on a number of different things having to do withlighting and we can explore the nextaspect of our game after this.In the next video, we are going to touch on how we can make use of trigger

### Using Triggers for Gameplay Effects

	In this video, we are going to touch on one of the most common ways to havethings happen inside of our levels. Ifyou played a game like Uncharted or TombRaider or any action-adventure game, youmay notice that entering an area, it starts off where there are no enemiesthat are all but once you drop down or once you enter in an area, all of asudden a bunch of enemies showed up. Now the computer wasn't necessarily smartenough to know that. Generally, thosethings are pre scripted and designersput in these invisible boxes that when the player hits them causes certainthings to happen. We're going to see how you can do that inside of your projectsand how to do it specially when dealing with VRTK.So for our first example of doing usinga trigger volume for a gameplay element, maybe that whenever the player enters anarea then we want to have some enemiesspawn and start going after the player. This is something that's done quiteoften in games like Tomb Raider or othervarious games where you typically enteran area. I'm going to start off by turning off the lighting so we can kindof see real easy here. But you'll noticethat I've built this level in such a way that it's impossible to go into thisroom without going from here into thisarea. So what we're going to do is we're going to say once the player enters thisarea then we're gonna spawn some enemies.But in our case, let's we need to decide where we want to put theseenemies and I'm gonna put them inside ofthis room. So I'm just gonna go ahead andstart off by duplicating this zombieenemy and bring it inside here. Butrather than starting the game with all the zombies already in the game andalready looking at they're going after the player, I'm gonna make it so thisenemy will only spawn or will only existonce the player enters that trigger. SoI'm gonna go ahead and click on thischeck mark to effectively turn it off.Likewise, I'm gonna also duplicate this acouple more times and we're gonna duplicate the zombie enemy, bring in acouple let's say four here. Sure, let's addsome more variation so they're not allat the same position but let's do likethat do like that, bring all four,turn them off. All right, so what we'regonna do next is we need to create atrigger. So simple enough, we'll just goahead and we will create a new gameobject, will go 3D game objects create a cube.We will scale it so that it's big enoughto fit this whole area. Let's make the Ylike this, make the Z like this. Basically,you just want to guarantee that if the player comes into this area we're gonnaspawn those guys for it. And where ourdifferences come across is we're first off going to turn off the mesh rendererand then under the box collider, we're gonnacheck the is trigger property. Now bybeing a trigger, we are saying that wecan still detect collision events, it'sjust that we will not react to them using physics so it won't prevent ourplayer from entering the area or prevent others from being able to move withinthere. So we now need to create a script to basically say hey, when we come inhere we want to do something. So we're gonna go to the project window here,right click create C# script and from there, we're gonna go ahead and giveit a name. Let's call it a trigger spawnerand we'll double-click on it to open it up in Visual Studio.All right, so in our case here we aregoing to need to have a an objectcontain all of the objects that we want to spawn or all of the objects that wewant to turn on. And so to do this we'regoing to make a list.So we're calling it to spawn and it's alist of game objects and because I've marked it as public, that means it'sgoing to show up in the inspector later on. Now we're not going to be using startor update so we're going to remove them.But we are gonna make use of a functionwhich is called ontriggerenter.Now the ontriggerenter function takes inone parameter which is of typeCollider 2D. Ontriggerentertakes in a colliderand we'll give it a name of collider. Nowinside of here, we need to actually say what to happen whenever we actuallyenter this area. So what we basicallywant to do is whenever we enter thisparticular trigger, we want to turn on all of these objects inside of tospawn.So to do that we can make use ofsomething called a for each loop whichlooks something like this.And this is saying, for every objectinside of tospawn, we are going toinitialize each element as obj, obj is aquick for those of you who are familiar working with a general for loop, this issimilar to doing everything that the general for loop does. Just that if youaren't going to remove elements ormodify the array in any way, it's a quick way to get the effect that you generallywhen using a for loop. And all we're gonna do is we're gonna turn on theobject, so we can just say obj dot setactive to true. Go ahead and return tothe inspector here and I'm going to goto our trigger cube which I'm gonnaname trigger.Assign the trigger spawner to itand then you'll see to spawn here. NowI'm gonna go ahead and select all four of these objects or rather I'm going toselect the trigger. I'm gonna lock the inspector so it won't go away from here.Grab the four objects and then drag anddrop them inside here. So now let's goahead and jump in the game and see whathappens. All right, so at this point itmay seem that when we come up here thereare enemies. But there's more of this than meets the eye.Now the first that you may think is thatour code works exactly correctly but thething is is that the code is actuallybeing triggered by the zombie moving,because the zombie has a rigidbody. If we start the game and it starts moving,we're going to see all four of these zombies just automatically turn on andthat's not necessarily what we want. We want to be when the player enters thisarea, that's when we spawn these guys. Soto fix that, there's a couple things weneed to do. Currently, if we open upour script aliases our headset does nothave a way to detect collision butthankfully, VRTK has a component built in which is made for this particularpurpose to actually have detection onwhether a headset is actually within a volume or not. And that component iscalled the VRTK headset collisioncomponent. If we select that, has a coupleof options, has a radius for our colliderwhich is gonna follow our camera followour head and we'll detect that these collisions happen. And if we play thegame now, I'm gonna go ahead and unmaximizethe screen and if we open up theSDK manager and go to our SteamVR righere. If we select our inside camera, the headset aliasyou'll see that has another object herewhich is called VRTK autogen headsetcollider controller. It has a rigidbody,it has a sphere collider with the sizethat we specified, it also has acomponent called VRTK headset collider.That means that if this object has thatcomponent on it, that must be the player.So let's go inside of our script againand let's check if the object is theobject that we've collided with which collider contains information about, hasthat component. So let's go ahead and say if collider.getcomponentVRTK dot VRTKunderscore headset collider. So if thisvalue from getcomponentis not nullthen we want to do this for each loop. Sowe go ahead and copy this outand paste it here. Let's save the scriptand run it one more time. So here we go,we got this guy and looks like no spawninggoing on just yet but we enter here andthere they are. Perfect. You may have alsonoticed that our trigger volume actuallyupsets our raycasts as well. We don'tnecessarily want that to happen, we want to have it so that these object doesn'tmodify how the teleport script works. Butthankfully, if we change the layer of thisobject to ignore raycast, now when weplay the game you should be able to see us cleanly be able to teleport anywhereinside of the object. [Silence]And so with that, we've got ourfoundation. You also notice that there was an error because we hitontriggerenter again and the objects no longer existed. One way that we can tryand fix this is we can make this onlyhappen once. Alternatively, we can alsocheck if object self exists first.So if obj itselfis not null then do this.We can also have a private booland then inside here we can just ask,so if the value of has fired is false wewill execute this code. But then after weexecute this code, we say has fired istrue so this will only ever just happen once.And so with that, we now have a workingcollider. We have a working trigger thatwhen we collide with it with the headset will spawn the enemies for our player tohaste. And with that, we I'm sure you can come up with much more interestingcombat scenarios, which I hope that you'll come up with before we get to ournext section where we dive into building UI.Now that we've finished diving intobuilding our levels for our game, we wantto customize how our game actually looksfrom the users perspective. It's a factthat most games need to have menus and we're going to dive into different waysin VR of how to handle menus as well as

### Overlay UI versus World Space

	Section seven, creating the userinterface in game menus. Over the courseof this section, we're going to betalking all about UI or user interfacewhich is actually one of the most important things to have inside of yourgames. If players don't know the correctinformation while they're playing the game on whether things are workingcorrectly or not or how to do things, they're going to have a terrible timeplaying your game. And working with UIwith VR is no exception. It's even moredifficult in some ways due to the fact that the most case, the UI elements haveto actually be inside of a 3D space itself. And we'll be discussing that aswell as how you I can be done inmultiple ways by both creating a UIelement with our guns and also how tocreate a main menu to our game as well.To get started, I think it's a good idea for us to talk about some of thedifferences between doing UI for VR aswell as traditional games. And that involves us talking about the concept ofoverlay UI versus World Space UI. Sofirst off, we have overlay UI and this ishow most games that you play istypically done or this is rather howmost games typically do their UI, especially for console games as well asmobile games and PC games. Because it'sthe traditional way, this is actually theUnity's default setting for UI objectswhen you create a canvas, which is the holder of UI elements inside your gameis set by default to have a draw mode ofoverlaying on top of the camera. And as Imentioned before, this UI is basically alayer on top of the camera, basicallyoverlaying everything to display different information. And no matter howmuch your camera moves, you're going toalways see this UI on the screen. You mayhave seen already while playing this video series that there was a UI elementin the top right of the screen that wascreated by default VRTK. But if you've played a game before like forinstance Sonic, Mario or most shooter games,you traditionally see like the player's health on the screen. You see how manybullets they have on the screen. Thisisn't possible for VR game or at leastyou can't use this system because Unitysupported being used for that. So instead we make use of what's calledWorld Space UI. Now World Space UI isbasically where instead of having the UI being placed inside of the screen,instead it's placed inside of the worlditself. Think of it similar to a planewhere instead of it just being ground on top of the screen, is instead just a flatpiece of geometry that can be placedanywhere in the world and it can havescales, rotations etc etc etc. This wasfirst made popular with the dead spacegame that EA worked on and later becamepopular with the borderlands series. Andby default, this means that this UI staysin one place. For VR, this means that theplayer can move around the UI, they canlook at it at different angles. And thisis how you have to create your UI whenyou're dealing with VR games. Now, if youwould like to have overlay like behaviorwhat we can do is we can actually usethe concept of parenting, where you can drag and drop an object on top ofanother object and it would become a child of that parent object. And so ifthe parent object moved, you could movethe UI element as well. Generally for VRgames, we typically recommend not doing that because that may help promotedizziness where people just always see something on the screen no matterwhat's going on. For those of you who would like to take a closer look at howthese different UI modes interact andhow they might be interesting for VR,Kelsey Shanahan here has created aawesome article talking all about howdead space gave a number of differentlessons for creating VR projects. And so for instance, it does talk about howdead space has their UI inside the worldof the game itself as opposed to something like this which is using anoverlay, like from the original Mass Effect game.And so I highly suggest that you take alook at this for when you're deciding orlearning about how to build your UIobject. In the next video, we are going to be talking about the concept ofdisplaying information to our playermaking use of our first UI element which

### Displaying Information via Text

	In this video, we discuss our first UIcomponent which is the text component,which will allow us to display text onthe screen. We'll also learn how we canhave this actually exist within the world, making use of the concepts that welearned in the previous video. The first UI element that we're going to becreating is going to be some text todisplay, you know how many bullets thatthe player has in their weapon. So okaysimple enough. But we no longer need to use ProBuilder in order to do that soI'm going to go ahead and close the ProBuilder window. And what we're going todive into is go to from project and goinside of our assets FPS game and thenopen up the prefabs folder. And fromthere we're going to look at the handgun prefab.Now, you may notice that when we play thegame, from the inspector we have this UIelement. If you're actually using the OculusRift, you won't actually see that becauseUnity doesn't support showing overlayinformation with VR. So what we're goingto do is we're going to make use of aworld space element. So back in our scenetab where we've got our gun here and what we're basically going to do is makeit so that we will place a UI elementbeside the gun to actually say how manybullets we currently have in our chamber.One quick way to make it easy to see here is I'm gonna go ahead and switchthis button here to move 2D mode. Now 2Dmode we kind of see from a top-downperspective what this area actuallylooks like. And the handgun itself iscurrently laying down, okay simple enough.So what we're going to do is we're going to create a UI element, so I'm going togo ahead and go to game object UI andthen we're going to go ahead and selectcanvas. Now, the canvas object is actuallyif you double click on it you will seethis huge overlay on the screen and thecanvas is basically a holder for UIelements and UI elements that you want to have inside of your game. Now thedefault render mode is set to screenspace overlay but as it's shows here, it says that the canvas won'tactually be seen when you're playing the game in VR. So if you go to render mode,let's go ahead and change it from overlay to instead be set to world space.And this is basically effectively saying,hey I want this object to be somewhereinside of the world. Now if you look atthis, our gunis much smaller than this UI element. Sowe actually want this to be much smaller than what was there currently. The firstthing I'm going to do is notice that instead of a transform, this now haswhat's called a rect transform or arectangular transform. Whereas instead ofjust being one point, a one rotation ofone scale it's actually dictating a boxwith a starting point in a width and aheight. And so the first thing we're gonna do is I'm gonna go ahead and zeroeverything out, so I'm gonna go ahead andsay pose X pose Y and pose z will all beat zero. And this will effectively Centerthis actual object so we've got that centered and if we zoom in well enoughwe will see our gun. But in addition tothat, we're also going to probably want to change the width and the height ofthis. Now by default, it's one unit is onepixel in terms of space inside of Unity.But we would probably want this to be much smaller. Let's make it somethingsmaller, like let's just do like 100 100here and again still quite large, like ifI double click here quite large. But we can use the scale component here to makeit much smaller as well. So I'm gonna go ahead and say point zero one maybe pointzero one in the X and the y. And okayyeah, so that's much closer to the sizeof our actual image. Now the canvasitself is a holder for UI elements but this currently won't have any visualelement at all, let's go ahead and changethat. If you right click on the canvasfrom the hierarchy window here, you cango ahead and under here you'll see there's a whole section of UI objectsthat we can add to our scene. And in our case, we're just going to go ahead andselect text and that will add this textobject here into our scene. Now it's a little hard to see here but you'll seeit says new text. To make it easier to see, the first thing we could do is we couldchange this color so instead of just being a black here we can change it tomaybe being white. And we can also changeit to be much maybe smaller or bigger. Ifyou notice right now, it does seem to be kind of pixelated for what we'recurrently been dealing with here but we can definitely work on fixing that.Inside of new text here, we can put inwhatever text we want to display on this object and so for instance if we wantedto say that we have ten bullets in this gun, we can go ahead and say like ten. Andthe general idea here is under alignment,we can arrange things to be vertically aligned. So I'm going to center thisvertically and I want to position thisso that it's actually to the right ofthis gun. So right now we won't actuallysee things because it's outside of our canvas here, but if I go to the canvasyou'll see that there is this z-rotation that's been placed and currently it's atnegative 90. If I rotate this back tozero, you'll see that it pops on out overhere, it's actually rotating this text object. I'm going to go ahead and dragthis over so it's just next to this thisgun here. There we go. So now you'll seethat we currently have the gun andthere's a big ten over to the right of us.That's a good starting place but obviously we can make things look awhole lot nicer here. The first thing that we're going to probably want to do is we're going to want to change thesize of this art, like the notice thelarger the size is less pixelation thereis. And what we can do is let's actuallymake the width something like 300 so it's actually bigger was therepreviously, and we'll actually justdecrease the scale even more. So I'mgoing to say point zero five maybe pointzero zero five. Okay,that's getting better. Maybe make it evensmaller like 0.3 so zero point zero zerothree here, cool. And with the text object,we're gonna move it a little bit furtherdown as well and I think I'm actuallygonna move it up so it's like facing this top of this object. So we're gonnatweak the Y and make it face upwardshere. The next thing we're gonna do isI'm going to also right now everything'sblack so it's a little easy to see. But I'm gonna also click on add componentand add in outline to this as well. Sothe outline actually adds a little black border along this but we can of coursechange the color as well. The defaultversion gives some transparency here. I'm going to turn it all the way up and I'mgonna make it two negative two to make it a little more visible that there'sactually an outline being displayed here. And another thing we could potentiallydo is there's a property here calledbest fit, if you check that it willautomatically resize the object to fit inside here and it doesn't really mattertoo much for this. Let's go ahead andlet's make the height of this muchbigger. So maybe when we get 60 tall andwe will make the text size bigger sothat it becomes more clear,so maybe 53 here. And then we'll use thescale to make it smaller, so if I make it point five here 0.5you'll see that it's much cleaner interms of how it visually looks. So that'slooking good. Now let's go ahead and run into the game again and we'll see howthis visually appears. Alright, so this islooking a whole lot better. We can tellthat our gun has a 10 being displayed bythe name and it's looking good.Now our next goalis going to be to make it so that whenever we shoot, we're gonna see thegun actually update how many bullets wehave in this chamber and also add in theability to reload. In the next video, weare going to learn how to take this UI element and update what it displays

### Updating UI Elements Through Code

	In this video, we are going to take our text element that we created in theprevious video and learn how to updateit to then display information throughcode. We will also expand upon this in order to make it so that our player canactually reload his actual weapon. Inorder to have our UI actually update atruntime, we're going to need to startdiving into some code. So let's go ahead and open up. From the project window gointo FPS game and then select scriptsand we're going to dive back into ourhandgun script again. So again, we're going to dive back to our handgun scripthere, we'll close this up. And the first thing we need to do is figure out rightnow all we have here is this fireprojectile function and we want to makeit so that we will display informationfor the UI each time we fire a shot.So to start off with, we're going to need to introduce a couple new variables.We're going to need how big do we wantour magazine to be and how many piecesof ammo do we want to have.And in my case, I'm just going to defaultmagazine size to 10 and what we'll do iswhen we start the game, we'll set ourammo count to our magazine size. So let'sgo ahead and add the search function.All right, simple enough but now how dowe actually tell the UI to do this forus. Well we need to have access to theactual text component. Now this textcomponent is, the definition for thecomponent is located within the Unityengine dot UI namespace. So I could writeum you know I can put here,public Unity enginedot UI dot txt.But and we can give it a nameammo text but generally whenever I workwith UI. So I don't have to do this every single time I want to use somethingthere, we can just add to the top of this fileUnity engine dot ui and then I could justsimply get rid of this text right here.It will assume because we put text here, itlooks at these namespaces first. And sonow inside, we can assign this value andonce it's been assigned we can justupdate it. We can update the text on thetext object by modifying a propertywhich is also called text.So in this case, I'm changing the textsto now display ammo and I'm callingthis function called to string. It is a goodidea to do because the text itself is astring and this will this function willconvert any object into a string thatcan be parsed. And now what we'll do, if we start the game it'll actually justsay ten still but let's make it so thatwhenever we fire projectile, we will go ahead and shrink the amount of ammo thatwe have. So inside of here after we play oursound effect, we'll say ammo minus minus which willdecrease the value of ammo by one andthen we'll update the UI in the sameexact manner we did before.All right, so let's dive into Unity andsee what happens. So before we can go into Unity, we actually have to assignthis text object. So with the hand gun selectedyou'll see that we have ammo text which is now a property which is currently set to nothing.So let's go ahead and assign the textobject to it and now let's play. Alright,so as you can see it starts off with avalue of 10 and when we shoot, itdecreases for us. Now of course at thispoint, we actually go less than zero as well. We obviously don't want that tohappen and what we can do is we canbasically say when we run out of ammo, weactually want to reload our camera. Solet's learn how we can do that. So to do this, let's go ahead and diveback to our handgun here. And the first thing we want to do is we want toprevent us from being able to fire ifthere's no ammo at all. So I'm gonna goahead and sayif our ammo is greater than zero then wedo this. And after we shoot, we can justautomatically make it that if there's no more ammo then we should start reloading.So let's go ahead and add in a checkhere and say ifif our ammo is equal to zero we're gonna call this function called reload. Nowreload currently doesn't exist so weshould probably implement that. So let'sexit this function, which is right herethen we'll create this reload function here.Now the reload function is basicallywhere we are going to wait a certainperiod of time and then we will updateour ammo to be back to the originalmagazine size. So just for the sake ofplayers being able to know that we are actually doing something when this isbeing called, let's use the let's set thetext to say that we're reloading.So we're updating the text and then we want to wait a certain period of timeand then we can display you know thatwe've finished reloading. One way that wecan call code being delayed for acertain period of time is through a function called invoke. Now the invokefunction takes in two parameters, thefirst being what is the name of thefunction that you want to call after this period of time. And we'll justcreate a function called finish reload.And then the second parameter is going to be how long do you want to waitbefore the reload finishes. So we can of course create a variable to hold herebut I'll just put in one second.Now if we try to run this right now, we are going to display the reloading textand nothing's going to happen. After a second, it's going to try to call finishreload but it currently doesn't exist solet's go ahead and update that as well.Make sure that your spelling of the function is actually the exact same ashere or the code will not work correctly.So in our case we're going to reload, we're gonna set our ammo back to magazinesize, we're gonna update the text to beback to the ammo. And so I'm going to sayammo text dot text is equal to ammo dottostring. And so now, if we go ahead and westart the game here so now if we start firing at this guy,oh we're saying reloa but then it comesback. So to fix the reloa, if you open uphere and you go to text you'll see thatour current size is actually smaller than it would need to be in order to display.Notice that when I type it in here it isactually being displayed but it's not displaying all the characters. However, ifwe expand the width to be higher you'll see that it actually starts beingdisplayed. But we want to make sure that all of our stuff actually fits withinour canvas so we either need to extendour canvas size or we can resize thiselement itself. And we could do that bywe could modify the scale of the objectby clicking on scale here, and we cangrab the white section here to scaleboth at the same time and bring it downto fit our scene. All right, so we've gotour UI here. Now it's displayingreloading for usand then we're able to fire again.Awesome. Now we might want to have theability to be able to click a button toalso reload. Maybe we go to six and we don't want tohave to go all the way down to zero before we start reloading. So we can goahead and add that and real quick as well but that's going to require us tomake use of another component inside ofVRTK. Inside of our scene, there'sactually not inside of herebut inside the game itself you will finda component called VR controller events.And that's going to be located insidethe VRTK script aliases and if you openit up and you go to our controller rightor left here, you will see there's a VRTKcontroller events script here.And this component contains informationabout button presses that are currentlyhappening and one of those parameters is abool called button 1 pressed and button2 pressed, which relate for the Oculus tobeing the a and B buttons respectively.So what we can do is really quickly justgo inside here.We can add to the top of our codeusing VRTK, because that is thenamespace that the controller events areand I usually I like to add a comment when I'm using it for a particular class.That way I know why I'm using it and wecan just create a variable called eventsand we'll just call it events. And theninside of the start function,in this case here game object definedobject of type will look through our scene until it finds an object with thiscomponent attached to it. And what we cando is ask, if we are pressing this buttonthen call the reload function as well.So there's button one pressed butthere's other events as well.So there's pressed, released, touch start,pressed will be if you hold down that button.All right, so let's go ahead dive backinto Unity and if we try the game again.Now, if we press the a button we go toreloading and we're back to 10.Now you may notice that I can stillshoot when I'm pressing both buttons atone time. We don't necessarily want thisto happen, so what we can do instead is we can say if we're in the process ofreloading don't allow us to be able toto fire again.So we will add a new boolean variablefor whether we are reloading.Inside our start we'll say that we're not reloadingand then inside here we can ask,if we're pressing a button and we're notreloading call reload. And then in here,if our ammo is greater than zero and andwe're not reloading, I'll usually addparentheses on both sides of here to make it easier to be able to read what'sgoing on.And then inside here when we call reload,we'll say reloading is true and thenwhen we finish reloading then we'll setit back to false.All right, so nowand now as you can see our reloadingworks correctly. So with this, we canstart exploring some other ways that wecan use UI inside of our game projects.In the next video, we are going to create

### Building the Main Menu

	It's one thing to actually display texton the screen and update it with things happening in the game but the other mainway that you use UI in games to be able tointeract, things like for instance menus.In this video, we are going to discusshow to create a menu for VR. We're goingto create a brand new scene and we'regoing to introduce the button componentto work with. We're also going to see howwe can use our VR controllers to be ableto select and activate this new element,this new UI element. So in this video,we're going to be creating a titlescreen for our game and the player canpress a button to load our current leveland enable us to be able to play and tofinish the game. So do that, we're goingto need to create another level which means we need to figure out what partsof this level do we want to bring intothe next one. In our case, it is the SDKmanager but also the script aliases aswell. So I'm going to hold down the ctrl key and select both of these objects andthen hit ctrl C. From there, we'll goahead and create a new scene which we'lldo by going to file new scene and thenwe're gonna be brought to this new level.For this new level, we actually don'tneed this original main camera so I'm going to go ahead and delete it from my scene,and then I'm gonna go ahead and pastethe assets that we previously copied. And we'll just go ahead and moveeverything to the top. Let's go ahead and run the game and see what we currentlyhave. As you can see right now, both theguns work we can shoot them and if weclick on we've got our drawers. Now inour case right now, we can't actually teleport anywhere because there's novalid ground but that's okay because we're going to be creating a titlescreen. So for the purpose of this level,we don't necessarily need the guns toactually be there. In fact, we probably just want to have the pointers there sothat we can see where we could potentially click the buttons that wereeventually going to be creating. So with that in mind, the first thing that we'regoing to do is we're gonna go ahead and open up the VRTK script aliases andwe're going to need to look at both theleft and the right controller script. Now the right one, we don't have this manythings to change so we'll dive into there first. Now we still want to have controllerevents because we want to be able topush a button to activate things. And wealso want to have our renderer, in thiscase the straight pointer renderer. Nowin our case though and the VRTK pointerwe want to have as well, except in our case we don't necessarily need to haveteleporting so we can just disable thisif we want to. From here as well but inthis game we don't necessarily need that,we just need to work with UI. So we canclick this little checkmark to disablethe component or we can right click onthe component and select remove. Either way will work and we will also don'tneed interact grab or interact use,and in this case object Auto grab isused to give us the handgun originally. We don't need that as well so I'm goingto right click as well and remove it. So in this case, we just have the pointer,the renderer and the controller events.We're going to do the same thing for theleft hand side as well. I'm gonna go ahead and keep the pointer,keep the controller events and in ourcase, we actually don't want to have a Bezier pointer because we actually wantto be able to project where our cursor is currently pointing to make it easy totell whether or not we can activate abutton or some other UI element. So I'm going to right click on the rendererhere and remove it and we're going to do the same thingwith the others. So remove the touch,remove the grab,remove the use and remove the auto grab.And then afterwards, just addor the straight pointer renderercomponent and we can just keep thedefault values for right now. But let's go ahead and play and see where we're at.We want to have it so that the pointersare always being displayed on the screen.We can easily do that by scrolling downto the straight pointer renderer component and you'll see under thetracer visibility and cursor visibility,they're currently set to on when active but we can also just turn it on and sayalways on.Same thing here and we can do the samething on the right hand side as well.Our next step is going to actually to beto create the main menu itself. So that means that we're going to need to createanother canvas like we've discussed previously. So I'm going to go ahead andgo to game object UI and then selectcanvas. So the canvas object, we'vediscussed before is a holder of variousUI elements and just like before we needbecause we're doing a UI game, we must change the render mode from screen spaceoverlay to instead be world space. Nowafter that, we need to actually make this into a place that players can actuallysee what's going on here. So I'm going togo ahead and change the X & Y to 0 0and if we double-click now, you'll seeit's positioned as such. Now this is muchlarger than say how big our actualobject is in the scene. So I'm going togo ahead and revise the size of this canvas. Let's make this scale somethingsmall zero zero five point zero zerofive and now you'll see that we're muchcloser to where we were before. But I'malso wanting to push this out a little bit to make it a little easier for ouruser to see. Like let's say maybe anegative three for right now and we'llsee where this is on the screen once we actually have something inside here. Andwith that in mind, let's create our firstnew UI element which will be a button. SoI'm going to right click here and we'llgo ahead and select UI. And before we create the button, let's first create ourtext to display the name of our game. SoI'm going to go ahead and select UI textand you'll see that currently it isbeing displayed here on the screen. Itlooks like it's positioned in such a waythat we can't actually see. We're seeing it backwards so let's go ahead and grabthe canvas and move it so instead of being negative three, let's move it topositive three and we'll rotate itaround later if we need to. So from here,it just currently says new text. Let's goahead and increase the size of this somaybe something like 300 or 350.And let's make the height something muchlarger like 100.Like we've discussed before, the text component has a number of ways that wecan customize how this actually looksincluding alignment and I'm going toalign it in the middle, both horizontallyas well as vertically. Now we now need todecide what the name of our games goingto be. In our case, we are making a horrorshooter that we're fighting zombies so let's say let's call it zombie fight orzombie shooter. And so with that in mind,we've got zombie shooter here and we're going to increase the size so that itfits inside of our area here. And let'sgo ahead and hit the play button. And it looks like if I look at the bottom ofthe screen, we can see the words zombie shooter. So we're probably going to wantto move it up just a little bit so thatit's facing us when we start the project. So with that in mind, we are facing thecorrect direction which is great but dueto the position being at zero in the yaxis, that's effectively saying we wantto be directly on the floor. We want tobe upwards. Now in Unity units, one Unityunit is one meter off the floor. So forinstance, if I change the position hereto say one that will move all of our UIelements to now be one meter above theground. Now that might be a goodplacement for our button, let's maybemove the text to be a little higher. SoI'm going to change the Y on this guy toinstead be higher. Now notice that thevalue for pose Y is much larger when Imodify it through here rather thanthrough the canvas itself. In this case here, I set the zombie shooter to belet's say 120. And the reason why is thatwhen you're dealing with objects withinthis space, it's not dealing with thisscale right. It thinks that the scale is1 1 1 and so acts as if it's moving upone pixel of space. And so, in our casehere now if we go ahead and play the game we should see this text beingdisplayed a little higher on the screen.All right, looking good. So now we need toactually have our UI elements actuallydo something. So the first UI elementthat we are going to deal with is ourbutton or the next UI element that we're going to be dealing with is a button cut,the button object. And we can create a button by right-clicking on our canvasand then selecting a UI button.All right, so the button itself looks alittle bit like this. The button isactually consisting of two UI elements,if you'll open it up you'll see buttonand you'll see text. Now you may seethese yellow lines. These are referringto how the connections between differentUI elements exist. This normally won't bevisible but if you do see it if you go to the button component and undernavigation you click on visualize, thatwill disable it or enable it. So thebutton object itself handles how thebutton should react. In this case, there'sdifferent colors that used for different interactions and different things thatcould happen when you click the button.There's also this text that is just atext object like what we did with zombie shooter here, and I'm going to change this so that instead of just sayingbutton it's going to say start game.Simple enough. With this in mind, there isa couple things that are not included which will make it so that these buttonscan't actually function when working onour project. The first thing is thatevery object inside Unity, Unity's UIsystem that requires any kind of eventsto trigger, so for instance pushing a button, hitting a slider, anythingrevolving that requires a game objectwhich is called an event system. Nowyou'll see that there is an event systemgame object but it's inside disabledevent system here from the SDK systemsetup switcher. And if we play the game, Idon't use the Oculus Rift here but you'll see that we have these buttons. Sothese buttons exist and this event systemexists, but if there is no event systemyou must add one to your project.The second thing is that this canvassystem works correctly for non UIprojects but in order to make it workwith UI stuff, you have to add anothercomponent which is called the VRTK UI canvas.This basically says that VRTK shouldrespond to these UI events.Likewise, inside of both our leftcontroller and right controller scriptaliases we need to add another componentwhich is called a VRTK underscore UIpointer. This component allows us to havepointers actually do something for us. Let's go ahead and play the game andwe'll see what this does. All right, so a couple things that youmay notice. You may see that our screennow shows up as being green when we'reinside the canvas in red when we are not.But you'll also notice that by default it doesn't appear as if the buttonactually does anything. And that'sbecause by default, VRTK requires youto have some way of activating thesebuttons. Now in my case, I'm able toactivate it by clicking on my analogstick and when I click then I can usethe trigger in order to press the actualbutton. But that is not necessarily howwe want this to work. We want the players to always, like if I move the mouse overhere I should be able to click andselect the button.With both of your left controller script aliases selected, go ahead and scroll allthe way down to your VRTK UI pointercomponent. From there, you'll see that there are a couple of different optionswhich allow us to decide when the UIshould be activated or not. If you go toactivation mode, sorry activation mode here you'll see thatthere's hold a button, the touchpad in order to have the activation work. Toggle it oralways on, for this instance I'm going touse always on. And so now, with both ofthese being selected it modifies both at the same time. And now if we play thegame, you should seethat now whenever I hover here, it is highlighted and I can use the triggerjust click the button. So as you can see, we can actually click on the button butthe button doesn't actually do anything so that's what we're going to need to donext. And that is going to require us toactually write a script. In the nextvideo, we're going to explore how we can make this menu actually do thingsthrough the use of writing a C#script and then hooking it up so that whenever we click on the start game

### Scripting UI Interactions

	While Unity's built-in UI elements aregreat, by default they just function butthey don't do anything to actually modify the game. In order to do that,we're going to have to make use of writing C# scripts and in thisvideo, we're going to explore how to dothat and then how we can hook up theconnection between Unity's UI system and calling code that we've writtenpreviousl. In order for our button to goto another level, we're going to have towrite another script. And so with that inmind, we are going to go to the FPS gamefolder, open up scripts and we're goingto create a new C# script whichwe're going to call main menu behavior.We'll go ahead and double-click on it and open it up. So in our case, we don'tactually need to have these start and update functions so I'll go ahead andremove them.What we do want to do though is create apublic function that we can then callthrough the inspector. So we're going to create a public function so I writepublic and then void, so no return typeand we're going to name this function load level.Now load level is gonna be a functionthat we're going to have actually taking our parameter. I'm gonna have it taking astring which will be the level that we want to load.Now, in order to load the level we'regoing to need to make use of a componentor rather we're going to have to make use of a class called the scene manager,and that exists in the the Unity enginedot scene management namespace. So I'm gonnago ahead and remove these and addusing Unity engine scene management. Nowonce I've done that, I can just writescene managerdot load scene and load scene is afunction that has a number of different versions of it. But the version thatwe're going to use is this one that justtakes in a string which is the name of the level that you want to load. So I'mgoing to go ahead and type in level name,and with that we'll go ahead and savethe script.We'll then go ahead and select our startgame button and from the inspector, ifyou scroll on down to the buttoncomponent you'll see this list here foron click. We basically want to call thisparticular function or we want to call our load level function. So we're goingto go ahead and hit the plus here and I just want to point out that I see a lotof people drag and drop the scriptinside of here. And if you do that, itwill fill this area with a drop down butwith this drop down you're only going to see this one option monoscript and name.What you have to do if you want to call a function that's been written on acomponent, you need an instance of that component and that means that thiscomponent needs to be on an actual gameobject. So for our case, let's go aheadand create a game object to hold thismain menu behavior. So I'll right click and we'll create an empty object, rightclick create empty and I'll just give ita name after initializing its positionto zero zero zero. Now effectively, thisis for no reason other than neatness. I'm going to drag and drop the main menubehavior in here to create an instance of this class. I'm going to name theobject main menuand then from my button, we'll go aheadand drag and drop this game objectinside of here. Now once we've done this,you'll see the drop down actually has an option for every component that's beenattached to the object, including the main menu behavior that we've created.And you'll see here all of the different public variables that have been given tothis object, including load level. Nowload level has this area here for us tobe able to type in something which is going to be the name of the level thatwe want to load. If we go to our scenesfolder, you'll see that we have this testbed level which is what we're usingfor the most current version of our project. So I'm gonna go ahead and namethis testbed.Lastly, I want to save this level so thatwe have a reference to it later on, so I'm going to go ahead and save thislevel by saying you know file save. It's going to ask us where we want to saveour level, so I'm going to go ahead and open up the FPS game, go to scenesand then I'm going to name the level totitle screen.Once I've done this, if we play the game right nowwe'll get the following.All right, so I'm in the game. I'm able tomove my controller and I'm able to clickon the button. And you'll notice that instead we have thiserror. Let me go to the console, says testbed can't be loaded because it's notinside the build settings. So in our case,we need to go to file build settingsand you'll see here this is the this is the menu that we use in order to exportour game, but it's also used to tell theUnity what levels do we actuallywant to have in our project. Because you know, we oftentimes will create maps thatwe don't necessarily want to include in the final version of our game, thingslike testbeds. But in our case, we'reusing our testbed as our final level. Sowe need to add some scenes here to thisbuild. The first thing we want to do iswe want to add our title screen. I can click the add open scenes button and itwill add our level that we currently have loaded. We can also add new scenesthis by dragging and dropping them intohere. Now the important thing to note ison the top right on the right hand side here, you'll see that there is a numberbeing indicated here. When you exportyour game, whatever number is at the topor rather whatever scene is at the top is going to be the level that startswhen you start the game. In our case, wewant that to be the title screen so let's go ahead and run the game now andsee what happens. So from here, you should be able toselect this button and when you click it with the trigger,now we're inside of our level.So with that, we now know that our buttonis working correctly and we've seen howwe can have UI elements call code that we've written.In the next section, we are going to betalking about how to optimize our projects so that they can run as efficientas possible, since that is one of the most

### Introducing the Rendering Statistics Menu and Profiler

	Section 8, optimization techniques. Whenyou are creating a project for VR, you are rendering two different eyes at thesame time. That means that twice as muchcomputation is being done in order todraw things to the screen. So just likewhen working for for simpler things likemobile devices, you have to spend a lotof time to ensure that your projects areoptimized so that they run well on all ofthe different devices that are possible for dealing with VR. Introducing therendering statistics menu and profiler.In order for our games to be optimized,it's an important to have an understanding of what aspects of thegame need to be optimized. And so to helpwith that, we're going to introduce two ways to determine what parts of our gameshould be fixed with the renderingstatistics menu and the profiler. Whencreating a game for VR, it's generally an accepted practice that we need to getour game in such a way that it runs at90 frames per second. If it is lower than that, that means that's gonna be likelyto induce disorientation, nausea andother negative user effects so that'sdefinitely something that we don't wantour users to have to go through. And the lower the framerate of the game, the worse theeffects were going to see and so thegoal of VR developers is to ensure thatour games are as always at 90 FPS orhigher. But the question is, how do wefigure out what our fps is. Well theeasiest way is through the renderingstatistics menu and you can access it byclicking on the game tab. And then fromthere, if you'll move over the screen you'll see that there's a little buttonhere which is called stats. If you clickon that, it'll bring up this statisticsmenu. It's a little hard to read righthere so let's go ahead and hit play and we'll see what this looks like. So as youcan see, right now this is filled up witha bunch of different information about the current statistics of our game. Nowthe key one that we're going to care about here is this section right herewhich is our FPS or frames per second.And right now we currently have it goingsomewhere around 600 to 700 fps. Nowthat's perfect I want to have inside ofour game and this is a good indicator for us to know how fast or how slow ourgame is actually going. Now of course, when we start thegame we're going to have a lot moreissues because this level is just youknow blank, it's just with UI nothingelse inside of it here. As you can seehere right now, we're playing the game,I'm currently getting a FPS of about 60frames per second. Now the reason that this is actually happening is becauseI'm using a screen recording softwarewhile this is going on, so that is takingup computation time and when the is not runningI'm normally getting a hundred to a hundred and twenty FPS. Now there are anumber of different sections in here which you may want to look at. I'm goingto use my mouse to point them out here. You'll see so we've got our time framealready here with our fps which isframes per second and the MS here is howmuch time in milliseconds is elapsing between each of the frames inside of ourgame. There's another section here whichis called batches and the batches sectionis where the engine is going to attemptto look for all the things in our scenethat use the same type of memory andwill try to reduce the CPU overhead dueto resource switching. And you'll see that there's a section here which iscalled saved by batching. This is thenumber of things that were able to be combined, which means that they had thesame materials within these particularobjects. Later on, we'll see how we canimprove this even more by batchingmultiple textures into one particular object.There's also the section here for trisand verts. Tris stands for, or triesstands for triangles that are currentlybeing drawn and you'll notice that when I move my mouse over the zombie, it'smuch higher than when I'm not. And that's because that's what's visually beingseen inside of our project. You'll alsosee that there is the vert stands forvertices. There's also a section for thescreen which is how big this screen isand how much memory is currently beingused by doing it. Set pass is the numberof rendering passes that have to gothrough it and yeah, so hopefully thisgives you a good ideaof how well it is doing. You know, seeright now our FPS has gone up to the 120130 range. Now you might be wonderingwhat specifically is causing this renderdrop and that's going to lead us to our next menu that we're going to care about,which is the profiler. You can access theprofiler by going to window then goingto analysis and then selecting profiler.Now this is going to bring up a new menuthat looks something like this. Now depending on what's going on insideyour game, you'll see that we have a bunch of information that's currentlybeing displayed here. Now, you'll also seeon the top here. This is the CPU usagethat's currently being used by ourproject. Now at any time, we can pause ourgame to see how this is working. So forinstance if I hit pause, you'll see everything here has now paused so thatwe can examine it further. Now insidehere we have a bunch of different colors and these colors are indicating how muchtime is being used by particular things.Now the largest one you'll see here isthis green section and the green sectionis actually for the rendering side ofthings. Then here's our scripts, how much time it takes to do physics calculations,any animations and this allows us to seewhat is causing us to take how much timeof computation for our game. This also contains information about how it takesto render, how much memory is being used all sorts of fun things to take a lookat here. Now if you select any of theseframes, it will show you underneath herehow much time is being spent onparticular function calls. So for thisparticular frame, which we're currently at this is the amount of time that'stake to do it.And if you click on any of these, youwill see the name of the function that's currently being used for this. Now inaddition to the timeline mode, if you click here you'll see there's a sectioncalled hierarchyand this is what I typically use. Ittells us how much of a percentage is being used of this particular frame forthese different sections, the editorloop being used by the Unity editor andthe player loop for the actual playing of the game. Now when we export theproject, the editor loop won't be therebecause there won't be a Unity editor to work with, so we're gonna deal with primarilythe player loop. Now inside of here, you'll see that there is a section forcamera rendering as well as our update.And you'll see here there's a list of all these different things that arebeing used including the scripts thatwe've created. So for instance here, underthese script run behavior updates you'llsee that the SteamVR render model istaking 5.9 percent of this particularframe. And so you can go through here andyou can search not only for VRTKstuff but for things that you've written yourself. So for instance, our handgunclass. We are calling handgun update andyou can see that it's not really takingup any time at all for us to be able to work with. But you can also type in thename of any function inside here and you should be able to find it.So for instance, we type an update we'llsee all of the different updates thatexist inside of our project. And so inour case here, we can also sort so forinstance I can sort by the time. I can sort by how much total it's going totake of our time to render. And you'llsee that we can use this to determinewhat are the things in our project thatwe would want to optimize, becauseoftentimes you don't want to optimize code before you know that it's going tobe taking up a long time. Now in this case here, you'll see behavior update istaking 15.8% of our frame and so thatmay be a function that we would want tolook at in the future. So now we know howto tell what parts of our project weactually want to know if we need tooptimize, and now we'll see some of theways that we can go about doing theoptimizing. In the next video, we aregoing to learn about the concept of a

### Creating a Texture Atlas

	antto note that the MA Toolkit does not work correctlywith ProBuilder meshes but it will workperfectly fine with objects in our scene,such as the things that we've grabbedfrom our horror Hospital pack. And so,right now you'll notice that all of ourhospital objects, they all have texturesof 1024 by 1024, they have meshes and etcetc. Now what we can do is we can make itso that instead of each of these having their own materials, we can instead havethem share and we can go ahead and dothat by go ahead and selecting MAToolkit MA_TextureAtlasser Proand then from there open up the Atlas editor. This will bring up a menu thatlooks something similar to this and there are two options here, one forloading an Atlas information thatalready exists and one from creating one from scratch. We'll go ahead and click onthis button to create one from scratch.It's going to ask us what do we want tocall our Atlas. Well these are the props for our level so I'm going to go aheadand name it props.And then under the atlas width and if Iuncheck this it'll be the height, it's how large do I want to have all of theseimages be. I'm going to go ahead andchange it to 1024and that's going to be the size of allof the atlases put togethe. Sso effectively I'm going to reduce the sizeof each of these by 1/4, not only savingdraw calls but also saving memory. So goahead and click create atlas and then it's gonna bring up this menu right here.Now currently, there are no atlasesavailable but we can go ahead and createone by clicking on this little buttonright here. It's going to create a new quad, a new texture for us to work withand we're basically can drag this overin order to determine how this should bedrawn. I'm gonna go ahead and grab this and move it over to the side here andthis information on the left is information about this particular quad.So for instance, if I want to grab thebed here I could just grab this textureand drag it here into the albedo. Thatmeans that that is going to be filled in here on this image. There's also asection here called meshes which isasking what meshes use this texture. Inthis case, it's just the one, just the bedso I'm gonna go ahead and hit plus. Now I'mgonna drag and drop the bed inside herebut I can't drag the prefab, the object. Ihave to open this up and this is theactual mesh file. So we're gonna go ahead and drag that inand so, once we create this texture itwill assign to this bed correctly. Afterwards I'm going to go ahead andgive this a name of bed and in additionto the albedo or the diffuse channel,there's also a normal for thisparticular object as well. In addition to having just one texture here, we can goahead and create a second by clicking onthis button and then clicking here to create a second texture group for us touse. In this case, this is the normal mapso I can type in normal and then dragand drop this in here. Now that we have this finished, so we can just go ahead andcreate a new texture to work with. I'm going to go ahead and click on this plusbutton here and this will create a newone from scratch. I delete it by clickingon this and this actually created a duplicate of the one that was herebefore. So you see that there's bed andhere is new bed. I can go ahead and go toa second object here like for instancethe cables, and I can assign herethe cables diffuse under albedo. We don't have a normal map so I'll delete thatand then under the cables, we'll go aheadand select the mesh and then assign it right here.Again, we can go enroll, want to renamethis as well two cables. We can go ahead and do the same thing, let's selectsomething a little more complex let's say the electric panel here. The panelactually contains this mesh plus thesetwo images or these two materials tothem. So we can go ahead and duplicatethis or create a new one from scratch. We can create a new one from scratch here,use the mouse wheel to zoom ,click and drag.And we will go ahead and drag this out,512 bring it down.And in this case we want to use this forthe albedo, this for the electric panel,and the mesh is right here. We'll goahead and hit plus, drag the mesh in andthen lastly, once you've finished addingall of these to your project you can go ahead and click on this button righthere which is for export. Oh, as an aside you can also click on thisbutton here to make each of the textures visible that you're going to be using. Sowe'll go ahead and click on the export button here and it's going to containinformation on how these are going to beexported. If you want to just keep the default settings as is, you can justclick export or you can create a new settings by clicking on this buttonright here. If I go ahead and hit export,go ahead and it should be finished now. We can go ahead and close out of thesemenus and you'll see that if we go tothe MA Toolbox folderand we open up the TextureAtlasser Prohere you'll see under there's a folderhere called exports. And as you can seewe have a bed, we have the bed with thematerial, cables cables of the material,and the electric box with and withoutthe material. And so now, these are allinstead of using the original materialare instead using props which is this guy right here.And so this significantly reduced thedraw calls and we can use them in placeof our original props. In the next video, we are going to learn how to optimizethe polycounts of the meshes in ourobject and ways to make meshes simplifywithout actually causing much of aperformance concern by making use of LOD

### Optimizing Mesh Polycounts with Blender and LOD Groups

	Optimizing mesh polycounts with Blenderand LOD groups. Now of course when we areup close to an object, we want it to haveas much detail as possible so that ourusers feel like they're actually insideof the environment that they're at. But when we are looking at an object fromfurther away, we can actually lose someof that detail without the playeractually noticing. And while Unity doesnot provide a way for us to be able todo this automatically, we can make use ofBlender in order to simplify meshes andthen we can use Unity's concept of LODor level of detail groups in order to beable to draw smaller these less complexobjects when they're further away fromour player, allowing us to get performance gains without the playeractually noticing that we're doing this. Now in order to go through the meshsimplification process, we first need tofigure out what mesh it is that we wantto simplify. If we go through ourproject so far, most of our rooms are just boxes which can't really besimplified too terribly much. However, ifwe open up the horror hospital packand go to our models here, you can see that if we go to let's say the stretcherhere. If you open this upand select the mesh associated with it,it will tell us how many triangles andhow many vertices this is and right now thisis a thousand vertices. That could bequite useful if we're up close to theobject but if the object is further awayfrom us, we probably don't need it tonecessarily be this detailed. And so oneof the ways that we can do this is wecan simplify this original mesh. Now ifwe go ahead and right click here and sayshow and explore, you'll see us broughtto this menu with this FBX file. In theFBX file is the 3D object that we weregiven when we ran this project. NowUnity doesn't provide any built-in wayfor us to do the simplification so we're going to need to make use of analternative tool. Now, if we go ahead inour case we're gonna make use of thefree Blender tool. Now you can getBlender by going to blender.org anddownloading it right here. Now once it's finished downloading and installing,you'll be able to work with it. Uponopening Blender for the first time, you're going to see something like thefollowing. We're just gonna keep everything to the default and then we'regonna go ahead and hit next.Once here, we can go ahead and click on anew file general and then we'll be brought to something that looks like thefollowing. Now, we don't need to have anyof these objects inside our scene so I'm gonna go ahead and select the cube andright click delete, the light right clickdelete, camera right click delete andthis brings us to an open scene that hasnothing in it. And I can use the mouse wheel by clicking it and dragging it tomove around this particular scene. Now we want to go ahead and bring in ourstretcher and we can do that by going tofile import fileand then selecting FBX. From there, you'regoing to go ahead and copy paste thefolder that our stretcher is at, visit itand then go ahead and click on the FBXright here. We'll leave all the detailsto for the defaults and here it is,here's our original object and I use themouse wheel to zoom in here. Now in ourcase, the way that Unity is set up thisobject is currently named as this objectright here. Now in our case, what we are going to want to do is create something calledan LOD group, which makes it so that asthe object gets far away, it will usethe simplified version of the mesh thatwe've created. Now on Unity's manual forthe level of detail page, it specifiesthat when you import your mesh that you need to use a certain naming conventionin order to make use of the level ofdetail system, at least by default or to have Unity do it automatically. Andthat involves using an underscore LODand then a number from zero which meansfull detail, and then one for less detail,two for lesser detail, so on and so forthfor how you want the object to be lesserdetailed. So with that in mind, let's go ahead and take this object and we candouble click in order to rename this. I'm gonna go ahead and rename it and add tothe end of it LOD zero. Now, after we'vedone that we're going to go ahead and duplicate this mesh and we can do thatby hitting ctrl Z or ctrl C and thencontrol V. We're then going to rename theobject to use LOD one instead, and thisis where it comes to actually simplifying the mesh. Now of course wecould go through here by hand and try tominimize how large it is, but underneathhere there's a section with a little wrench called modifier properties andwe're going to make use of a modifier instead. From here, we'll clickadd modifier and then you'll see a number of different options here and oneof which is called decimate. And decimatewill remove vertices from thisparticular object. With selected, there'sa section called ratio which is how manytriangles should we reduce in thisobject. So for instance, if I change theratio to say 0.5 notice that it seems tohave less detail than what was therebefore. We're gonna go ahead and do thesame thing for another level of detail. Copy/paste,change this to LOD 2 and then under ourratio here we can also click and drag to bring it down. Now notice that if you gotoo far down, it starts to break down themesh. I think something like 0.25works pretty well here. Again, remember that we're not going to be looking atthis object this closely. Instead, it's going to look like this and at thispoint you can't really tell the difference between the original andbetween this. Once you've gone ahead anddone this, we're gonna go ahead and hit the apply button to actually have thismodifier actually happen. Do the samething for LOD one and then we can goahead and export this model. So again,we're gonna go ahead and say file exportFBX. Go back to the folder where we werebefore and this time I'm going to renamethis to stretcher 2.0. We'll go ahead andhit export and as long as we did it in the samefolder, now we return to Unity you'll seethat stretcher 2.0 is now an object thatexists here. And let's go ahead and moveinto our scene, and we'll go ahead and take thisoriginal stretcher and drag this newstretcher in here.Now notice that unlike our originalstretcher, this one here has a newcomponent added to it called LOD group.Now, if I open up this stretcher you'llsee that unlike the original stretcher here, you'll see that there are actuallythree objects inside of here, each namedcorrectly based off the LODs that weprovided before. And if we zoom out thecamera, you'll see at the camera updateshere in LOD group. Now right here, it's using LOD zero which means the fullresolution version of this object. If I go far enough back,like for instance if we go over hereyou'll see that it's going to switch LODone. If I go further away back, switchesto LOD 2 and if I go even further backeventually it's going to cull it, which means it's not going to draw it at all.Now each of these can also be tweaked.So for instance, if I think I should usethe lower detail version further away, like for instance if I'm further awaythan here you can click and drag this to make it switch earlier than what wasthere before. And for instance too, you can also make it like if you go too faraway, maybe here you switch it to LOD twoand if you want to be further away tocull you can do that as well. There is asection as well for fade mode, like forinstance this right now will instantly switch between them but you can also setit to crossfade or to do a speed tree.And so again, it's just however you wantto have these draw but this will make itmuch more efficient to have lots of things on your screen further away. Andagain, I can just go here select this. Ican right click copy the transform component,delete this stretcher and paste thecomponent here.And right now, it's rotated correctly butthere's some scaling issue. Let's change the scale to back to oneand there we go. So with that, we now havethis new stretcher that is much more efficient than what was there before. Inthe next video, we're going to discoverhow we can make use of the concept of occlusion culling to improve the

### Occlusion Culling

	Occlusion culling. When a player islooking through our scene, we expect tobe able to see all the objects inside ofour world but we don't necessarily needto show everything inside of our worldat all times. If for instance, if we'relooking forward we don't actually need to draw what's behind us because there'snothing of the players going to use thisfor. Likewise, this is something Unitydoes for us automatically but likewise,if there's a wall in front of us we don't need to draw anything that's infront of these walls. That's the conceptor that is how we can make use of theconcept of baked occlusion culling which is what we're going to be talking about in this video.By default, objects in Unity will draweverything in the direction that yourcamera is looking in. This includes eventhings that are behind walls. So forinstance, if I were following here I would want to be able to see anythinginside this room but if I'm like thisthere's no reason for me to draw all the things that are there, and yet that'swhat Unity will do by default. Thankfully,we can make use of the concept ofocclusion culling have us not do thatand save us performance in the mean time. This is actually something it'sincredibly simple to do. The main thing you need to do is you need to make surethat all of your objects that don't moveare marked as being static. Now we'vedone that already for our environmentbut we haven't necessarily done that forour object. The objects in our scene herethat won't be moving, like for instance the bed and for instance our stretchers.If you click on the static button orjust ensure the underneath here thatoccluder an occludees static arechecked then you'll be good to go to work with here. And again, in this placeright now it's talking a global illumination the reflection probe but wewant everything to be static,aside from objects that will move. Yes,change children and we will not be ableto mark the zombie as being staticbecause the zombie can actually move. Andagain our rooms are already marked asstatic and that should be good for us. Soafter we've marked everything as static, what we have to do is rather than duringcomputation time decide what should be drawn and what shouldn't, we'll insteaddo this beforehand by baking thisocclusion data. We can do that by goingto window and then under rendering go toocclusion culling. Now from here, it'sgoing to ask whether we want to do the entire scene or through certain rendersor through occlusion areas. In our case, we're just gonna do everything and ifyou click on the bake tab here you'll see that there are some defaultparameters. In general, the default isfine but if you have small cracks in your scene where you still want to beable to see things behind it, you're gonna need to tweak the smallest holedata. In our case, it's not really anissue but with that in mind, let's goahead and click on the bake button.Now once this is done, it switches us tothis third tab which is visualization. Now in our case because we have nocamera selected, we're not going to be able to see how this works but if we goahead and let's go switch to the gametab here. And with this in mind, let's goahead and hit the play button. So we'llundo the maximize unplayand notice [Silence]that as we move our head, we enable anddisable different aspects of the scenefor us to work with. And that's the wholeidea of occlusion culling. There's also asection here called visibility lines,which will show me how I'm determiningwhat is being seen and what isn't. So thiscan give you a better idea as to how theculling is being done. In the next video,we're going to see how in addition tonot rendering certain things, we can alsopre compute the lighting of a scene,which will also give us performance gains due to the fact that we can justbake this into the textures inside of

### Bake Lighting

	Bake lighting. In this section, we're going to see that just like when we areworking with occlusion culling,we can save ahead of time theinformation of how things should be let inside of our scene. This will allow usperformance gains due the fact that the computer doesn't need to compute thesethings at runtime and can make things easier for us.Just like we did with the occlusionculling, we can also bake in lightinginformation of lights that don't changeduring runtime in order to incrediblyimprove the performance gains of ouractual scenes. Now in order to do so,we're going to need to select any of thelights within our scene that will notmove then we can quickly figure out all the lights in our level by going to thehierarchy and typing in the name of the light component.And you'll see here we've got three point lights to look at, this point light,this point light, and this directionallight. Each of them have a different modeattached to it which is the real-timemode. Now real-time lights mean that it'sgoing to update during real-time so it can move, but in this case aren'tactually moving these lights. So we canchange this from real-time to instead be baked.And what baked does is it says that hey,instead of being displayed here like this save the information before thegame starts and this will have massiveperformance gains in our project. But just setting the mode to bake is onething, that doesn't actually update the information inside the game. To do that,we're going to need to go to thelighting tab. So go to windowrendering and then lighting settings.From there, there's a section calledbaked light maps and from there you'llsee it there's currently nothing. But under scene, let's change underenvironmental lighting. We can change theambient mode from real-time to baked andthen from there, we can go ahead and click on the generate lightinginformation. This may take a little bitof time but once finished, we should havesome good information for us to be ableto draw things at this rate.Another way to optimize your lighting isby disabling real time globalillumination. Basically, any time there'ssomething happening at runtime there'sgoing to be a performance cost and sowith that in mind, this should help youhave a much more optimized lighting withyour project as well. Alright and withthat, we've now completed our working onour VR game inside of Unity. Hopefully,you've learned a lot of new tools that you can make use of when you're creatingyour own awesome games using the powerof all of these exciting newtechnologies. Anyways, I look forward toseeing what you come up with and I hopet
